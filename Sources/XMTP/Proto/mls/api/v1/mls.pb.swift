// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mls/api/v1/mls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message API

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Sort direction for queries
public enum Xmtp_Mls_Api_V1_SortDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case ascending // = 1
  case descending // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ascending
    case 2: self = .descending
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ascending: return 1
    case .descending: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Xmtp_Mls_Api_V1_SortDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xmtp_Mls_Api_V1_SortDirection] = [
    .unspecified,
    .ascending,
    .descending,
  ]
}

#endif  // swift(>=4.2)

/// Full representation of a welcome message
public struct Xmtp_Mls_Api_V1_WelcomeMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_WelcomeMessage.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_WelcomeMessage.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessage.V1()
    }
    set {version = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable {
    case v1(Xmtp_Mls_Api_V1_WelcomeMessage.V1)

  #if !swift(>=4.1)
    public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessage.OneOf_Version, rhs: Xmtp_Mls_Api_V1_WelcomeMessage.OneOf_Version) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1, .v1): return {
        guard case .v1(let l) = lhs, case .v1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Version 1 of the WelcomeMessage format
  public struct V1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: UInt64 = 0

    public var createdNs: UInt64 = 0

    public var installationKey: Data = Data()

    public var data: Data = Data()

    public var hpkePublicKey: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Input type for a welcome message
public struct Xmtp_Mls_Api_V1_WelcomeMessageInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_WelcomeMessageInput.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessageInput.V1()
    }
    set {version = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable {
    case v1(Xmtp_Mls_Api_V1_WelcomeMessageInput.V1)

  #if !swift(>=4.1)
    public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.OneOf_Version, rhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.OneOf_Version) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1, .v1): return {
        guard case .v1(let l) = lhs, case .v1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Version 1 of the WelcomeMessageInput format
  public struct V1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var data: Data = Data()

    public var hpkePublicKey: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Full representation of a group message
public struct Xmtp_Mls_Api_V1_GroupMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_GroupMessage.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_GroupMessage.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_GroupMessage.V1()
    }
    set {version = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable {
    case v1(Xmtp_Mls_Api_V1_GroupMessage.V1)

  #if !swift(>=4.1)
    public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessage.OneOf_Version, rhs: Xmtp_Mls_Api_V1_GroupMessage.OneOf_Version) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1, .v1): return {
        guard case .v1(let l) = lhs, case .v1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Version 1 of the GroupMessage format
  public struct V1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: UInt64 = 0

    public var createdNs: UInt64 = 0

    public var groupID: Data = Data()

    public var data: Data = Data()

    public var senderHmac: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Input type for a group message
public struct Xmtp_Mls_Api_V1_GroupMessageInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: Xmtp_Mls_Api_V1_GroupMessageInput.OneOf_Version? = nil

  public var v1: Xmtp_Mls_Api_V1_GroupMessageInput.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Xmtp_Mls_Api_V1_GroupMessageInput.V1()
    }
    set {version = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Version: Equatable {
    case v1(Xmtp_Mls_Api_V1_GroupMessageInput.V1)

  #if !swift(>=4.1)
    public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessageInput.OneOf_Version, rhs: Xmtp_Mls_Api_V1_GroupMessageInput.OneOf_Version) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1, .v1): return {
        guard case .v1(let l) = lhs, case .v1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Version 1 of the GroupMessageInput payload format
  public struct V1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: Data = Data()

    public var senderHmac: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Send a batch of MLS messages
public struct Xmtp_Mls_Api_V1_SendGroupMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_GroupMessageInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a batch of welcome messages
public struct Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_WelcomeMessageInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A wrapper around the Key Package bytes
public struct Xmtp_Mls_Api_V1_KeyPackageUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The owner's wallet address would be extracted from the identity
  /// credential in the key package, and all signatures would be validated.
  public var keyPackageTlsSerialized: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Register a new installation
public struct Xmtp_Mls_Api_V1_RegisterInstallationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Key Package contains all information needed to register an installation
  public var keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload {
    get {return _keyPackage ?? Xmtp_Mls_Api_V1_KeyPackageUpload()}
    set {_keyPackage = newValue}
  }
  /// Returns true if `keyPackage` has been explicitly set.
  public var hasKeyPackage: Bool {return self._keyPackage != nil}
  /// Clears the value of `keyPackage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyPackage() {self._keyPackage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload? = nil
}

/// The response to a RegisterInstallationRequest
public struct Xmtp_Mls_Api_V1_RegisterInstallationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Upload a new key packages
public struct Xmtp_Mls_Api_V1_UploadKeyPackageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An individual key package upload request
  public var keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload {
    get {return _keyPackage ?? Xmtp_Mls_Api_V1_KeyPackageUpload()}
    set {_keyPackage = newValue}
  }
  /// Returns true if `keyPackage` has been explicitly set.
  public var hasKeyPackage: Bool {return self._keyPackage != nil}
  /// Clears the value of `keyPackage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyPackage() {self._keyPackage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyPackage: Xmtp_Mls_Api_V1_KeyPackageUpload? = nil
}

/// Fetch one or more key packages
public struct Xmtp_Mls_Api_V1_FetchKeyPackagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The caller can provide an array of installation keys, and the API
  /// will return one key package for each installation associated with each
  /// installation key
  public var installationKeys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response to a FetchKeyPackagesRequest
public struct Xmtp_Mls_Api_V1_FetchKeyPackagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Returns one key package per installation in the original order of the
  /// request. If any installations are missing key packages, an empty entry is
  /// left in their respective spots in the array.
  public var keyPackages: [Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An individual key package
  public struct KeyPackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keyPackageTlsSerialized: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Revoke an installation
public struct Xmtp_Mls_Api_V1_RevokeInstallationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationKey: Data = Data()

  /// All revocations must be validated with a wallet signature over the
  /// installation_id being revoked (and some sort of standard prologue)
  public var walletSignature: Xmtp_MessageContents_Signature {
    get {return _walletSignature ?? Xmtp_MessageContents_Signature()}
    set {_walletSignature = newValue}
  }
  /// Returns true if `walletSignature` has been explicitly set.
  public var hasWalletSignature: Bool {return self._walletSignature != nil}
  /// Clears the value of `walletSignature`. Subsequent reads from it will return its default value.
  public mutating func clearWalletSignature() {self._walletSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _walletSignature: Xmtp_MessageContents_Signature? = nil
}

/// Get all updates for an identity since the specified time
public struct Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountAddresses: [String] = []

  public var startTimeNs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to get any new or revoked installations for a list of wallet addresses
public struct Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of updates (or empty objects if no changes) in the original order
  /// of the request
  public var updates: [Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A new installation key was seen for the first time by the nodes
  public struct NewInstallationUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var credentialIdentity: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// An installation was revoked
  public struct RevokedInstallationUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A wrapper for any update to the wallet
  public struct Update {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampNs: UInt64 = 0

    public var kind: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update.OneOf_Kind? = nil

    public var newInstallation: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate {
      get {
        if case .newInstallation(let v)? = kind {return v}
        return Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate()
      }
      set {kind = .newInstallation(newValue)}
    }

    public var revokedInstallation: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate {
      get {
        if case .revokedInstallation(let v)? = kind {return v}
        return Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate()
      }
      set {kind = .revokedInstallation(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case newInstallation(Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate)
      case revokedInstallation(Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate)

    #if !swift(>=4.1)
      public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update.OneOf_Kind, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.newInstallation, .newInstallation): return {
          guard case .newInstallation(let l) = lhs, case .newInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.revokedInstallation, .revokedInstallation): return {
          guard case .revokedInstallation(let l) = lhs, case .revokedInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A wrapper for the updates for a single wallet
  public struct WalletUpdates {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var updates: [Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Pagination config for queries
public struct Xmtp_Mls_Api_V1_PagingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var direction: Xmtp_Mls_Api_V1_SortDirection = .unspecified

  public var limit: UInt32 = 0

  public var idCursor: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for group message queries
public struct Xmtp_Mls_Api_V1_QueryGroupMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Data = Data()

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Response for group message queries
public struct Xmtp_Mls_Api_V1_QueryGroupMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_GroupMessage] = []

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Request for welcome message queries
public struct Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationKey: Data = Data()

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Response for welcome message queries
public struct Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_Api_V1_WelcomeMessage] = []

  public var pagingInfo: Xmtp_Mls_Api_V1_PagingInfo {
    get {return _pagingInfo ?? Xmtp_Mls_Api_V1_PagingInfo()}
    set {_pagingInfo = newValue}
  }
  /// Returns true if `pagingInfo` has been explicitly set.
  public var hasPagingInfo: Bool {return self._pagingInfo != nil}
  /// Clears the value of `pagingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPagingInfo() {self._pagingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagingInfo: Xmtp_Mls_Api_V1_PagingInfo? = nil
}

/// Request for subscribing to group messages
public struct Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Subscription filter
  public struct Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var groupID: Data = Data()

    public var idCursor: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request for subscribing to welcome messages
public struct Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Subscription filter
  public struct Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationKey: Data = Data()

    public var idCursor: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Xmtp_Mls_Api_V1_SortDirection: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_WelcomeMessage: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_WelcomeMessage.OneOf_Version: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_WelcomeMessage.V1: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_WelcomeMessageInput: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_WelcomeMessageInput.OneOf_Version: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_WelcomeMessageInput.V1: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GroupMessage: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GroupMessage.OneOf_Version: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GroupMessage.V1: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GroupMessageInput: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GroupMessageInput.OneOf_Version: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GroupMessageInput.V1: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_SendGroupMessagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_KeyPackageUpload: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_RegisterInstallationRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_RegisterInstallationResponse: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_UploadKeyPackageRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_FetchKeyPackagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_FetchKeyPackagesResponse: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_RevokeInstallationRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update.OneOf_Kind: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_PagingInfo: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_QueryGroupMessagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_QueryGroupMessagesResponse: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest: @unchecked Sendable {}
extension Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.mls.api.v1"

extension Xmtp_Mls_Api_V1_SortDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SORT_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "SORT_DIRECTION_ASCENDING"),
    2: .same(proto: "SORT_DIRECTION_DESCENDING"),
  ]
}

extension Xmtp_Mls_Api_V1_WelcomeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessage.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessage, rhs: Xmtp_Mls_Api_V1_WelcomeMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessage.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_WelcomeMessage.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_ns"),
    3: .standard(proto: "installation_key"),
    4: .same(proto: "data"),
    5: .standard(proto: "hpke_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.hpkePublicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 2)
    }
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.hpkePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hpkePublicKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessage.V1, rhs: Xmtp_Mls_Api_V1_WelcomeMessage.V1) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.data != rhs.data {return false}
    if lhs.hpkePublicKey != rhs.hpkePublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WelcomeMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessageInput, rhs: Xmtp_Mls_Api_V1_WelcomeMessageInput) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_WelcomeMessageInput.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_WelcomeMessageInput.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .same(proto: "data"),
    3: .standard(proto: "hpke_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hpkePublicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.hpkePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hpkePublicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1, rhs: Xmtp_Mls_Api_V1_WelcomeMessageInput.V1) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.data != rhs.data {return false}
    if lhs.hpkePublicKey != rhs.hpkePublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_GroupMessage.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessage, rhs: Xmtp_Mls_Api_V1_GroupMessage) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessage.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GroupMessage.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_ns"),
    3: .standard(proto: "group_id"),
    4: .same(proto: "data"),
    5: .standard(proto: "sender_hmac"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createdNs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.senderHmac) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.createdNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdNs, fieldNumber: 2)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if !self.senderHmac.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderHmac, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessage.V1, rhs: Xmtp_Mls_Api_V1_GroupMessage.V1) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.senderHmac != rhs.senderHmac {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Mls_Api_V1_GroupMessageInput.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessageInput, rhs: Xmtp_Mls_Api_V1_GroupMessageInput) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GroupMessageInput.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GroupMessageInput.protoMessageName + ".V1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "sender_hmac"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.senderHmac) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.senderHmac.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderHmac, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GroupMessageInput.V1, rhs: Xmtp_Mls_Api_V1_GroupMessageInput.V1) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.senderHmac != rhs.senderHmac {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SendGroupMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendGroupMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SendGroupMessagesRequest, rhs: Xmtp_Mls_Api_V1_SendGroupMessagesRequest) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendWelcomeMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest, rhs: Xmtp_Mls_Api_V1_SendWelcomeMessagesRequest) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_KeyPackageUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyPackageUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package_tls_serialized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyPackageTlsSerialized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackageTlsSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyPackageTlsSerialized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_KeyPackageUpload, rhs: Xmtp_Mls_Api_V1_KeyPackageUpload) -> Bool {
    if lhs.keyPackageTlsSerialized != rhs.keyPackageTlsSerialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_RegisterInstallationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterInstallationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyPackage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyPackage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_RegisterInstallationRequest, rhs: Xmtp_Mls_Api_V1_RegisterInstallationRequest) -> Bool {
    if lhs._keyPackage != rhs._keyPackage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_RegisterInstallationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterInstallationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_RegisterInstallationResponse, rhs: Xmtp_Mls_Api_V1_RegisterInstallationResponse) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_UploadKeyPackageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadKeyPackageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyPackage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyPackage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_UploadKeyPackageRequest, rhs: Xmtp_Mls_Api_V1_UploadKeyPackageRequest) -> Bool {
    if lhs._keyPackage != rhs._keyPackage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_FetchKeyPackagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchKeyPackagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.installationKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.installationKeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_FetchKeyPackagesRequest, rhs: Xmtp_Mls_Api_V1_FetchKeyPackagesRequest) -> Bool {
    if lhs.installationKeys != rhs.installationKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_FetchKeyPackagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchKeyPackagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyPackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPackages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse, rhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse) -> Bool {
    if lhs.keyPackages != rhs.keyPackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.protoMessageName + ".KeyPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package_tls_serialized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyPackageTlsSerialized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackageTlsSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyPackageTlsSerialized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage, rhs: Xmtp_Mls_Api_V1_FetchKeyPackagesResponse.KeyPackage) -> Bool {
    if lhs.keyPackageTlsSerialized != rhs.keyPackageTlsSerialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_RevokeInstallationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeInstallationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "wallet_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._walletSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try { if let v = self._walletSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_RevokeInstallationRequest, rhs: Xmtp_Mls_Api_V1_RevokeInstallationRequest) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs._walletSignature != rhs._walletSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIdentityUpdatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_addresses"),
    2: .standard(proto: "start_time_ns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accountAddresses) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.startTimeNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accountAddresses, fieldNumber: 1)
    }
    if self.startTimeNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimeNs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesRequest) -> Bool {
    if lhs.accountAddresses != rhs.accountAddresses {return false}
    if lhs.startTimeNs != rhs.startTimeNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIdentityUpdatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".NewInstallationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "credential_identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.credentialIdentity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if !self.credentialIdentity.isEmpty {
      try visitor.visitSingularBytesField(value: self.credentialIdentity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.credentialIdentity != rhs.credentialIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".RevokedInstallationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_ns"),
    2: .standard(proto: "new_installation"),
    3: .standard(proto: "revoked_installation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestampNs) }()
      case 2: try {
        var v: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.NewInstallationUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .newInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .newInstallation(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.RevokedInstallationUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .revokedInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .revokedInstallation(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampNs, fieldNumber: 1)
    }
    switch self.kind {
    case .newInstallation?: try {
      guard case .newInstallation(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .revokedInstallation?: try {
      guard case .revokedInstallation(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.Update) -> Bool {
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.protoMessageName + ".WalletUpdates"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates, rhs: Xmtp_Mls_Api_V1_GetIdentityUpdatesResponse.WalletUpdates) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_PagingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PagingInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .same(proto: "limit"),
    3: .standard(proto: "id_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.idCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    if self.idCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.idCursor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_PagingInfo, rhs: Xmtp_Mls_Api_V1_PagingInfo) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.idCursor != rhs.idCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryGroupMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGroupMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryGroupMessagesRequest, rhs: Xmtp_Mls_Api_V1_QueryGroupMessagesRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryGroupMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGroupMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryGroupMessagesResponse, rhs: Xmtp_Mls_Api_V1_QueryGroupMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryWelcomeMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest, rhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesRequest) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryWelcomeMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "paging_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagingInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try { if let v = self._pagingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse, rhs: Xmtp_Mls_Api_V1_QueryWelcomeMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs._pagingInfo != rhs._pagingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeGroupMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest, rhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "id_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.idCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.groupID, fieldNumber: 1)
    }
    if self.idCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.idCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter, rhs: Xmtp_Mls_Api_V1_SubscribeGroupMessagesRequest.Filter) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.idCursor != rhs.idCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeWelcomeMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest, rhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_key"),
    2: .standard(proto: "id_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.installationKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.idCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.installationKey, fieldNumber: 1)
    }
    if self.idCursor != 0 {
      try visitor.visitSingularUInt64Field(value: self.idCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter, rhs: Xmtp_Mls_Api_V1_SubscribeWelcomeMessagesRequest.Filter) -> Bool {
    if lhs.installationKey != rhs.installationKey {return false}
    if lhs.idCursor != rhs.idCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
