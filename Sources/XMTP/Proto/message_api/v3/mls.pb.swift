// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message_api/v3/mls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message API

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Publish a batch of MLS messages
public struct Xmtp_MessageApi_V3_PublishToGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Xmtp_Mls_MessageContents_GroupMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Publish a batch of welcome messages
public struct Xmtp_MessageApi_V3_PublishWelcomesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var welcomeMessages: [Xmtp_MessageApi_V3_PublishWelcomesRequest.WelcomeMessageRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An individual welcome message
  public struct WelcomeMessageRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The topic will be derived from this
    public var installationID: String = String()

    public var welcomeMessage: Xmtp_Mls_MessageContents_WelcomeMessage {
      get {return _welcomeMessage ?? Xmtp_Mls_MessageContents_WelcomeMessage()}
      set {_welcomeMessage = newValue}
    }
    /// Returns true if `welcomeMessage` has been explicitly set.
    public var hasWelcomeMessage: Bool {return self._welcomeMessage != nil}
    /// Clears the value of `welcomeMessage`. Subsequent reads from it will return its default value.
    public mutating func clearWelcomeMessage() {self._welcomeMessage = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _welcomeMessage: Xmtp_Mls_MessageContents_WelcomeMessage? = nil
  }

  public init() {}
}

/// Register a new installation
public struct Xmtp_MessageApi_V3_RegisterInstallationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var credentialBytes: Data = Data()

  public var signingKeyPublic: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_MessageApi_V3_RegisterInstallationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Upload one or more key packages
public struct Xmtp_MessageApi_V3_UploadKeyPackagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyPackages: [Xmtp_MessageApi_V3_UploadKeyPackagesRequest.KeyPackageUpload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An individual key package upload request
  public struct KeyPackageUpload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The owner's wallet address would be extracted from the identity
    /// credential in the key package, and all signatures would be validated.
    public var keyPackageTlsSerialized: Data = Data()

    /// The node will always treat the most recent last-resort key package as
    /// the active one, and will ignore all others.
    public var isLastResort: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Consume one or more key packages, removing them from further use
public struct Xmtp_MessageApi_V3_ConsumeKeyPackagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The caller can provide an array of wallet addresses, and the API
  /// will return one key package for each installation associated with each
  /// wallet address
  public var installationIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response to a ConsumeKeyPackagesRequest
public struct Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Returns one key package per installation in the original order of the
  /// request. If any installations are missing key packages,
  public var keyPackages: [Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse.KeyPackage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An individual key package
  public struct KeyPackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keyPackageTlsSerialized: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Revoke an installation
public struct Xmtp_MessageApi_V3_RevokeInstallationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var installationID: String = String()

  /// All revocations must be validated with a wallet signature over the
  /// installation_id being revoked (and some sort of standard prologue)
  public var walletSignature: Xmtp_MessageContents_Signature {
    get {return _walletSignature ?? Xmtp_MessageContents_Signature()}
    set {_walletSignature = newValue}
  }
  /// Returns true if `walletSignature` has been explicitly set.
  public var hasWalletSignature: Bool {return self._walletSignature != nil}
  /// Clears the value of `walletSignature`. Subsequent reads from it will return its default value.
  public mutating func clearWalletSignature() {self._walletSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _walletSignature: Xmtp_MessageContents_Signature? = nil
}

/// Get all updates for an identity since the specified time
public struct Xmtp_MessageApi_V3_GetIdentityUpdatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var walletAddresses: [String] = []

  public var startTimeNs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used to get any new or revoked installations for a list of wallet addresses
public struct Xmtp_MessageApi_V3_GetIdentityUpdatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of updates (or empty objects if no changes) in the original order
  /// of the request
  public var updates: [Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.WalletUpdates] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A new installation ID was seen for the first time by the nodes
  public struct NewInstallationUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// An installation was revoked
  public struct RevokedInstallationUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var installationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A wrapper for any update to the wallet
  public struct Update {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampNs: UInt64 = 0

    public var kind: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update.OneOf_Kind? = nil

    public var newInstallation: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate {
      get {
        if case .newInstallation(let v)? = kind {return v}
        return Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate()
      }
      set {kind = .newInstallation(newValue)}
    }

    public var revokedInstallation: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate {
      get {
        if case .revokedInstallation(let v)? = kind {return v}
        return Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate()
      }
      set {kind = .revokedInstallation(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Kind: Equatable {
      case newInstallation(Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate)
      case revokedInstallation(Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate)

    #if !swift(>=4.1)
      public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update.OneOf_Kind, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update.OneOf_Kind) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.newInstallation, .newInstallation): return {
          guard case .newInstallation(let l) = lhs, case .newInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.revokedInstallation, .revokedInstallation): return {
          guard case .revokedInstallation(let l) = lhs, case .revokedInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A wrapper for the updates for a single wallet
  public struct WalletUpdates {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var updates: [Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Xmtp_MessageApi_V3_PublishToGroupRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_PublishWelcomesRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_PublishWelcomesRequest.WelcomeMessageRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_RegisterInstallationRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_RegisterInstallationResponse: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_UploadKeyPackagesRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_UploadKeyPackagesRequest.KeyPackageUpload: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_ConsumeKeyPackagesRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse.KeyPackage: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_RevokeInstallationRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesRequest: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update.OneOf_Kind: @unchecked Sendable {}
extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.WalletUpdates: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.message_api.v3"

extension Xmtp_MessageApi_V3_PublishToGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishToGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_PublishToGroupRequest, rhs: Xmtp_MessageApi_V3_PublishToGroupRequest) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_PublishWelcomesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishWelcomesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "welcome_messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.welcomeMessages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.welcomeMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.welcomeMessages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_PublishWelcomesRequest, rhs: Xmtp_MessageApi_V3_PublishWelcomesRequest) -> Bool {
    if lhs.welcomeMessages != rhs.welcomeMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_PublishWelcomesRequest.WelcomeMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_PublishWelcomesRequest.protoMessageName + ".WelcomeMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_id"),
    2: .standard(proto: "welcome_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.installationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._welcomeMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.installationID.isEmpty {
      try visitor.visitSingularStringField(value: self.installationID, fieldNumber: 1)
    }
    try { if let v = self._welcomeMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_PublishWelcomesRequest.WelcomeMessageRequest, rhs: Xmtp_MessageApi_V3_PublishWelcomesRequest.WelcomeMessageRequest) -> Bool {
    if lhs.installationID != rhs.installationID {return false}
    if lhs._welcomeMessage != rhs._welcomeMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_RegisterInstallationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterInstallationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "credential_bytes"),
    2: .standard(proto: "signing_key_public"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.credentialBytes) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signingKeyPublic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credentialBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.credentialBytes, fieldNumber: 1)
    }
    if !self.signingKeyPublic.isEmpty {
      try visitor.visitSingularBytesField(value: self.signingKeyPublic, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_RegisterInstallationRequest, rhs: Xmtp_MessageApi_V3_RegisterInstallationRequest) -> Bool {
    if lhs.credentialBytes != rhs.credentialBytes {return false}
    if lhs.signingKeyPublic != rhs.signingKeyPublic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_RegisterInstallationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterInstallationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.installationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationID.isEmpty {
      try visitor.visitSingularStringField(value: self.installationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_RegisterInstallationResponse, rhs: Xmtp_MessageApi_V3_RegisterInstallationResponse) -> Bool {
    if lhs.installationID != rhs.installationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_UploadKeyPackagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadKeyPackagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyPackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPackages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_UploadKeyPackagesRequest, rhs: Xmtp_MessageApi_V3_UploadKeyPackagesRequest) -> Bool {
    if lhs.keyPackages != rhs.keyPackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_UploadKeyPackagesRequest.KeyPackageUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_UploadKeyPackagesRequest.protoMessageName + ".KeyPackageUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package_tls_serialized"),
    2: .standard(proto: "is_last_resort"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyPackageTlsSerialized) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLastResort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackageTlsSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyPackageTlsSerialized, fieldNumber: 1)
    }
    if self.isLastResort != false {
      try visitor.visitSingularBoolField(value: self.isLastResort, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_UploadKeyPackagesRequest.KeyPackageUpload, rhs: Xmtp_MessageApi_V3_UploadKeyPackagesRequest.KeyPackageUpload) -> Bool {
    if lhs.keyPackageTlsSerialized != rhs.keyPackageTlsSerialized {return false}
    if lhs.isLastResort != rhs.isLastResort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_ConsumeKeyPackagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsumeKeyPackagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.installationIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.installationIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_ConsumeKeyPackagesRequest, rhs: Xmtp_MessageApi_V3_ConsumeKeyPackagesRequest) -> Bool {
    if lhs.installationIds != rhs.installationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsumeKeyPackagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyPackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPackages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse, rhs: Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse) -> Bool {
    if lhs.keyPackages != rhs.keyPackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse.KeyPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse.protoMessageName + ".KeyPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_package_tls_serialized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyPackageTlsSerialized) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPackageTlsSerialized.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyPackageTlsSerialized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse.KeyPackage, rhs: Xmtp_MessageApi_V3_ConsumeKeyPackagesResponse.KeyPackage) -> Bool {
    if lhs.keyPackageTlsSerialized != rhs.keyPackageTlsSerialized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_RevokeInstallationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeInstallationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_id"),
    2: .standard(proto: "wallet_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.installationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._walletSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.installationID.isEmpty {
      try visitor.visitSingularStringField(value: self.installationID, fieldNumber: 1)
    }
    try { if let v = self._walletSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_RevokeInstallationRequest, rhs: Xmtp_MessageApi_V3_RevokeInstallationRequest) -> Bool {
    if lhs.installationID != rhs.installationID {return false}
    if lhs._walletSignature != rhs._walletSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_GetIdentityUpdatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIdentityUpdatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wallet_addresses"),
    2: .standard(proto: "start_time_ns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.walletAddresses) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.startTimeNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.walletAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.walletAddresses, fieldNumber: 1)
    }
    if self.startTimeNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTimeNs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesRequest, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesRequest) -> Bool {
    if lhs.walletAddresses != rhs.walletAddresses {return false}
    if lhs.startTimeNs != rhs.startTimeNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetIdentityUpdatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.protoMessageName + ".NewInstallationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.installationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationID.isEmpty {
      try visitor.visitSingularStringField(value: self.installationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate) -> Bool {
    if lhs.installationID != rhs.installationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.protoMessageName + ".RevokedInstallationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.installationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installationID.isEmpty {
      try visitor.visitSingularStringField(value: self.installationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate) -> Bool {
    if lhs.installationID != rhs.installationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_ns"),
    2: .standard(proto: "new_installation"),
    3: .standard(proto: "revoked_installation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestampNs) }()
      case 2: try {
        var v: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.NewInstallationUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .newInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .newInstallation(v)
        }
      }()
      case 3: try {
        var v: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.RevokedInstallationUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .revokedInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .revokedInstallation(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampNs, fieldNumber: 1)
    }
    switch self.kind {
    case .newInstallation?: try {
      guard case .newInstallation(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .revokedInstallation?: try {
      guard case .revokedInstallation(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.Update) -> Bool {
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.WalletUpdates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.protoMessageName + ".WalletUpdates"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.WalletUpdates, rhs: Xmtp_MessageApi_V3_GetIdentityUpdatesResponse.WalletUpdates) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
