// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: identity/associations/association.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Payloads to be signed for identity associations

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The identifier for a member of an XID
public struct Xmtp_Identity_Associations_MemberIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Xmtp_Identity_Associations_MemberIdentifier.OneOf_Kind? = nil

  public var address: String {
    get {
      if case .address(let v)? = kind {return v}
      return String()
    }
    set {kind = .address(newValue)}
  }

  public var installationPublicKey: Data {
    get {
      if case .installationPublicKey(let v)? = kind {return v}
      return Data()
    }
    set {kind = .installationPublicKey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    case address(String)
    case installationPublicKey(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Xmtp_Identity_Associations_MemberIdentifier.OneOf_Kind, rhs: Xmtp_Identity_Associations_MemberIdentifier.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.installationPublicKey, .installationPublicKey): return {
        guard case .installationPublicKey(let l) = lhs, case .installationPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// single member that optionally indicates the member that added them
public struct Xmtp_Identity_Associations_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _identifier ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  public var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  public mutating func clearIdentifier() {self._identifier = nil}

  public var addedByEntity: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _addedByEntity ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_addedByEntity = newValue}
  }
  /// Returns true if `addedByEntity` has been explicitly set.
  public var hasAddedByEntity: Bool {return self._addedByEntity != nil}
  /// Clears the value of `addedByEntity`. Subsequent reads from it will return its default value.
  public mutating func clearAddedByEntity() {self._addedByEntity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identifier: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _addedByEntity: Xmtp_Identity_Associations_MemberIdentifier? = nil
}

/// The first entry of any XID log. The XID must be deterministically derivable
/// from the address and nonce.
/// The recovery address defaults to the initial associated_address unless
/// there is a subsequent ChangeRecoveryAddress in the log.
public struct Xmtp_Identity_Associations_CreateInbox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var initialAddress: String = String()

  public var nonce: UInt64 = 0

  /// Must be an addressable member
  public var initialAddressSignature: Xmtp_Identity_Associations_Signature {
    get {return _initialAddressSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_initialAddressSignature = newValue}
  }
  /// Returns true if `initialAddressSignature` has been explicitly set.
  public var hasInitialAddressSignature: Bool {return self._initialAddressSignature != nil}
  /// Clears the value of `initialAddressSignature`. Subsequent reads from it will return its default value.
  public mutating func clearInitialAddressSignature() {self._initialAddressSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialAddressSignature: Xmtp_Identity_Associations_Signature? = nil
}

/// Adds a new member for an XID - either an addressable member such as a
/// wallet, or an installation acting on behalf of an address.
/// A key-pair that has been associated with one role MUST not be permitted to be
/// associated with a different role.
public struct Xmtp_Identity_Associations_AddAssociation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newMemberIdentifier: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _newMemberIdentifier ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_newMemberIdentifier = newValue}
  }
  /// Returns true if `newMemberIdentifier` has been explicitly set.
  public var hasNewMemberIdentifier: Bool {return self._newMemberIdentifier != nil}
  /// Clears the value of `newMemberIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearNewMemberIdentifier() {self._newMemberIdentifier = nil}

  public var existingMemberSignature: Xmtp_Identity_Associations_Signature {
    get {return _existingMemberSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_existingMemberSignature = newValue}
  }
  /// Returns true if `existingMemberSignature` has been explicitly set.
  public var hasExistingMemberSignature: Bool {return self._existingMemberSignature != nil}
  /// Clears the value of `existingMemberSignature`. Subsequent reads from it will return its default value.
  public mutating func clearExistingMemberSignature() {self._existingMemberSignature = nil}

  public var newMemberSignature: Xmtp_Identity_Associations_Signature {
    get {return _newMemberSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_newMemberSignature = newValue}
  }
  /// Returns true if `newMemberSignature` has been explicitly set.
  public var hasNewMemberSignature: Bool {return self._newMemberSignature != nil}
  /// Clears the value of `newMemberSignature`. Subsequent reads from it will return its default value.
  public mutating func clearNewMemberSignature() {self._newMemberSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newMemberIdentifier: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _existingMemberSignature: Xmtp_Identity_Associations_Signature? = nil
  fileprivate var _newMemberSignature: Xmtp_Identity_Associations_Signature? = nil
}

/// Revokes a member from an XID. The recovery address must sign the revocation.
public struct Xmtp_Identity_Associations_RevokeAssociation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var memberToRevoke: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _memberToRevoke ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_memberToRevoke = newValue}
  }
  /// Returns true if `memberToRevoke` has been explicitly set.
  public var hasMemberToRevoke: Bool {return self._memberToRevoke != nil}
  /// Clears the value of `memberToRevoke`. Subsequent reads from it will return its default value.
  public mutating func clearMemberToRevoke() {self._memberToRevoke = nil}

  public var recoveryAddressSignature: Xmtp_Identity_Associations_Signature {
    get {return _recoveryAddressSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_recoveryAddressSignature = newValue}
  }
  /// Returns true if `recoveryAddressSignature` has been explicitly set.
  public var hasRecoveryAddressSignature: Bool {return self._recoveryAddressSignature != nil}
  /// Clears the value of `recoveryAddressSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRecoveryAddressSignature() {self._recoveryAddressSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberToRevoke: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _recoveryAddressSignature: Xmtp_Identity_Associations_Signature? = nil
}

/// Changes the recovery address for an XID. The recovery address is not required
/// to be a member of the XID. In addition to being able to add members, the
/// recovery address can also revoke members.
public struct Xmtp_Identity_Associations_ChangeRecoveryAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newRecoveryAddress: String = String()

  public var existingRecoveryAddressSignature: Xmtp_Identity_Associations_Signature {
    get {return _existingRecoveryAddressSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_existingRecoveryAddressSignature = newValue}
  }
  /// Returns true if `existingRecoveryAddressSignature` has been explicitly set.
  public var hasExistingRecoveryAddressSignature: Bool {return self._existingRecoveryAddressSignature != nil}
  /// Clears the value of `existingRecoveryAddressSignature`. Subsequent reads from it will return its default value.
  public mutating func clearExistingRecoveryAddressSignature() {self._existingRecoveryAddressSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _existingRecoveryAddressSignature: Xmtp_Identity_Associations_Signature? = nil
}

/// A single identity operation
public struct Xmtp_Identity_Associations_IdentityAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Xmtp_Identity_Associations_IdentityAction.OneOf_Kind? = nil

  public var createInbox: Xmtp_Identity_Associations_CreateInbox {
    get {
      if case .createInbox(let v)? = kind {return v}
      return Xmtp_Identity_Associations_CreateInbox()
    }
    set {kind = .createInbox(newValue)}
  }

  public var add: Xmtp_Identity_Associations_AddAssociation {
    get {
      if case .add(let v)? = kind {return v}
      return Xmtp_Identity_Associations_AddAssociation()
    }
    set {kind = .add(newValue)}
  }

  public var revoke: Xmtp_Identity_Associations_RevokeAssociation {
    get {
      if case .revoke(let v)? = kind {return v}
      return Xmtp_Identity_Associations_RevokeAssociation()
    }
    set {kind = .revoke(newValue)}
  }

  public var changeRecoveryAddress: Xmtp_Identity_Associations_ChangeRecoveryAddress {
    get {
      if case .changeRecoveryAddress(let v)? = kind {return v}
      return Xmtp_Identity_Associations_ChangeRecoveryAddress()
    }
    set {kind = .changeRecoveryAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    case createInbox(Xmtp_Identity_Associations_CreateInbox)
    case add(Xmtp_Identity_Associations_AddAssociation)
    case revoke(Xmtp_Identity_Associations_RevokeAssociation)
    case changeRecoveryAddress(Xmtp_Identity_Associations_ChangeRecoveryAddress)

  #if !swift(>=4.1)
    public static func ==(lhs: Xmtp_Identity_Associations_IdentityAction.OneOf_Kind, rhs: Xmtp_Identity_Associations_IdentityAction.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createInbox, .createInbox): return {
        guard case .createInbox(let l) = lhs, case .createInbox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.add, .add): return {
        guard case .add(let l) = lhs, case .add(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revoke, .revoke): return {
        guard case .revoke(let l) = lhs, case .revoke(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changeRecoveryAddress, .changeRecoveryAddress): return {
        guard case .changeRecoveryAddress(let l) = lhs, case .changeRecoveryAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// One or more identity actions that were signed together.
/// Example: [CreateXid, AddAssociation, ChangeRecoveryAddress]
/// 1. The batched signature text is created by concatenating the signature text
///    of each association together with a separator, '\n\n\n'.
/// 2. The user signs this concatenated result.
/// 3. The resulting signature is added to each association proto where relevant.
///    The same signature may be used for multiple associations in the array.
public struct Xmtp_Identity_Associations_IdentityUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actions: [Xmtp_Identity_Associations_IdentityAction] = []

  public var clientTimestampNs: UInt64 = 0

  public var inboxID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Map of members belonging to an inbox_id
public struct Xmtp_Identity_Associations_MemberMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _key ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: Xmtp_Identity_Associations_Member {
    get {return _value ?? Xmtp_Identity_Associations_Member()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _value: Xmtp_Identity_Associations_Member? = nil
}

/// A final association state resulting from multiple `IdentityUpdates`
public struct Xmtp_Identity_Associations_AssociationState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inboxID: String = String()

  public var members: [Xmtp_Identity_Associations_MemberMap] = []

  public var recoveryAddress: String = String()

  public var seenSignatures: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// state diff between two final AssociationStates
public struct Xmtp_Identity_Associations_AssociationStateDiff {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newMembers: [Xmtp_Identity_Associations_MemberIdentifier] = []

  public var removedMembers: [Xmtp_Identity_Associations_MemberIdentifier] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Xmtp_Identity_Associations_MemberIdentifier: @unchecked Sendable {}
extension Xmtp_Identity_Associations_MemberIdentifier.OneOf_Kind: @unchecked Sendable {}
extension Xmtp_Identity_Associations_Member: @unchecked Sendable {}
extension Xmtp_Identity_Associations_CreateInbox: @unchecked Sendable {}
extension Xmtp_Identity_Associations_AddAssociation: @unchecked Sendable {}
extension Xmtp_Identity_Associations_RevokeAssociation: @unchecked Sendable {}
extension Xmtp_Identity_Associations_ChangeRecoveryAddress: @unchecked Sendable {}
extension Xmtp_Identity_Associations_IdentityAction: @unchecked Sendable {}
extension Xmtp_Identity_Associations_IdentityAction.OneOf_Kind: @unchecked Sendable {}
extension Xmtp_Identity_Associations_IdentityUpdate: @unchecked Sendable {}
extension Xmtp_Identity_Associations_MemberMap: @unchecked Sendable {}
extension Xmtp_Identity_Associations_AssociationState: @unchecked Sendable {}
extension Xmtp_Identity_Associations_AssociationStateDiff: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.identity.associations"

extension Xmtp_Identity_Associations_MemberIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "installation_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .address(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .installationPublicKey(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .address?: try {
      guard case .address(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .installationPublicKey?: try {
      guard case .installationPublicKey(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_MemberIdentifier, rhs: Xmtp_Identity_Associations_MemberIdentifier) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .standard(proto: "added_by_entity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._addedByEntity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._addedByEntity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_Member, rhs: Xmtp_Identity_Associations_Member) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._addedByEntity != rhs._addedByEntity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_CreateInbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInbox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_address"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "initial_address_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.initialAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._initialAddressSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.initialAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.initialAddress, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 2)
    }
    try { if let v = self._initialAddressSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_CreateInbox, rhs: Xmtp_Identity_Associations_CreateInbox) -> Bool {
    if lhs.initialAddress != rhs.initialAddress {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs._initialAddressSignature != rhs._initialAddressSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_AddAssociation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAssociation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_member_identifier"),
    2: .standard(proto: "existing_member_signature"),
    3: .standard(proto: "new_member_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newMemberIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._existingMemberSignature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newMemberSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newMemberIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._existingMemberSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newMemberSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_AddAssociation, rhs: Xmtp_Identity_Associations_AddAssociation) -> Bool {
    if lhs._newMemberIdentifier != rhs._newMemberIdentifier {return false}
    if lhs._existingMemberSignature != rhs._existingMemberSignature {return false}
    if lhs._newMemberSignature != rhs._newMemberSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_RevokeAssociation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeAssociation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_to_revoke"),
    2: .standard(proto: "recovery_address_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberToRevoke) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recoveryAddressSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberToRevoke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recoveryAddressSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_RevokeAssociation, rhs: Xmtp_Identity_Associations_RevokeAssociation) -> Bool {
    if lhs._memberToRevoke != rhs._memberToRevoke {return false}
    if lhs._recoveryAddressSignature != rhs._recoveryAddressSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_ChangeRecoveryAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChangeRecoveryAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_recovery_address"),
    2: .standard(proto: "existing_recovery_address_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newRecoveryAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._existingRecoveryAddressSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.newRecoveryAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.newRecoveryAddress, fieldNumber: 1)
    }
    try { if let v = self._existingRecoveryAddressSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_ChangeRecoveryAddress, rhs: Xmtp_Identity_Associations_ChangeRecoveryAddress) -> Bool {
    if lhs.newRecoveryAddress != rhs.newRecoveryAddress {return false}
    if lhs._existingRecoveryAddressSignature != rhs._existingRecoveryAddressSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_IdentityAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_inbox"),
    2: .same(proto: "add"),
    3: .same(proto: "revoke"),
    4: .standard(proto: "change_recovery_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Identity_Associations_CreateInbox?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .createInbox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .createInbox(v)
        }
      }()
      case 2: try {
        var v: Xmtp_Identity_Associations_AddAssociation?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .add(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Identity_Associations_RevokeAssociation?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .revoke(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .revoke(v)
        }
      }()
      case 4: try {
        var v: Xmtp_Identity_Associations_ChangeRecoveryAddress?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .changeRecoveryAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .changeRecoveryAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .createInbox?: try {
      guard case .createInbox(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .add?: try {
      guard case .add(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .revoke?: try {
      guard case .revoke(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .changeRecoveryAddress?: try {
      guard case .changeRecoveryAddress(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_IdentityAction, rhs: Xmtp_Identity_Associations_IdentityAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_IdentityUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .standard(proto: "client_timestamp_ns"),
    3: .standard(proto: "inbox_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.clientTimestampNs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inboxID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    if self.clientTimestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientTimestampNs, fieldNumber: 2)
    }
    if !self.inboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.inboxID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_IdentityUpdate, rhs: Xmtp_Identity_Associations_IdentityUpdate) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.clientTimestampNs != rhs.clientTimestampNs {return false}
    if lhs.inboxID != rhs.inboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_MemberMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_MemberMap, rhs: Xmtp_Identity_Associations_MemberMap) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_AssociationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssociationState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inbox_id"),
    2: .same(proto: "members"),
    3: .standard(proto: "recovery_address"),
    4: .standard(proto: "seen_signatures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inboxID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recoveryAddress) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.seenSignatures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.inboxID, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    if !self.recoveryAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveryAddress, fieldNumber: 3)
    }
    if !self.seenSignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.seenSignatures, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_AssociationState, rhs: Xmtp_Identity_Associations_AssociationState) -> Bool {
    if lhs.inboxID != rhs.inboxID {return false}
    if lhs.members != rhs.members {return false}
    if lhs.recoveryAddress != rhs.recoveryAddress {return false}
    if lhs.seenSignatures != rhs.seenSignatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_AssociationStateDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssociationStateDiff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_members"),
    2: .standard(proto: "removed_members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.newMembers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removedMembers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newMembers, fieldNumber: 1)
    }
    if !self.removedMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedMembers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_AssociationStateDiff, rhs: Xmtp_Identity_Associations_AssociationStateDiff) -> Bool {
    if lhs.newMembers != rhs.newMembers {return false}
    if lhs.removedMembers != rhs.removedMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
