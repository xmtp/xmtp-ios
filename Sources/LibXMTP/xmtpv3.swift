// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(xmtpv3FFI)
import xmtpv3FFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_xmtpv3_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_xmtpv3_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureXmtpv3Initialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol FfiConsentCallback: AnyObject, Sendable {
    
    func onConsentUpdate(consent: [FfiConsent]) 
    
    func onError(error: FfiSubscribeError) 
    
    func onClose() 
    
}
open class FfiConsentCallbackImpl: FfiConsentCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonsentcallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonsentcallback(pointer, $0) }
    }

    

    
open func onConsentUpdate(consent: [FfiConsent])  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonsentcallback_on_consent_update(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFfiConsent.lower(consent),$0
    )
}
}
    
open func onError(error: FfiSubscribeError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonsentcallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiSubscribeError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonsentcallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiConsentCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiConsentCallback] = [UniffiVTableCallbackInterfaceFfiConsentCallback(
        onConsentUpdate: { (
            uniffiHandle: UInt64,
            consent: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConsentCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConsentUpdate(
                     consent: try FfiConverterSequenceTypeFfiConsent.lift(consent)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConsentCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiSubscribeError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConsentCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiConsentCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiConsentCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiConsentCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_fficonsentcallback(UniffiCallbackInterfaceFfiConsentCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsentCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiConsentCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConsentCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConsentCallback {
        return FfiConsentCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConsentCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConsentCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConsentCallback {
    return try FfiConverterTypeFfiConsentCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentCallback_lower(_ value: FfiConsentCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConsentCallback.lower(value)
}






public protocol FfiConversationProtocol: AnyObject, Sendable {
    
    func addAdmin(inboxId: String) async throws 
    
    func addMembers(accountIdentifiers: [FfiIdentifier]) async throws  -> FfiUpdateGroupMembershipResult
    
    func addMembersByInboxId(inboxIds: [String]) async throws  -> FfiUpdateGroupMembershipResult
    
    func addSuperAdmin(inboxId: String) async throws 
    
    func addedByInboxId() throws  -> String
    
    func adminList() throws  -> [String]
    
    func consentState() throws  -> FfiConsentState
    
    func conversationDebugInfo() async throws  -> FfiConversationDebugInfo
    
    func conversationMessageDisappearingSettings() throws  -> FfiMessageDisappearingSettings?
    
    func conversationType()  -> FfiConversationType
    
    func createdAtNs()  -> Int64
    
    func dmPeerInboxId()  -> String?
    
    func findDuplicateDms() async throws  -> [FfiConversation]
    
    func findMessages(opts: FfiListMessagesOptions) async throws  -> [FfiMessage]
    
    func findMessagesWithReactions(opts: FfiListMessagesOptions) throws  -> [FfiMessageWithReactions]
    
    func getHmacKeys() throws  -> [Data: [FfiHmacKey]]
    
    func groupDescription() throws  -> String
    
    func groupImageUrlSquare() throws  -> String
    
    func groupMetadata() async throws  -> FfiConversationMetadata
    
    func groupName() throws  -> String
    
    func groupPermissions() throws  -> FfiGroupPermissions
    
    func id()  -> Data
    
    func isActive() throws  -> Bool
    
    func isAdmin(inboxId: String) throws  -> Bool
    
    func isConversationMessageDisappearingEnabled() throws  -> Bool
    
    func isSuperAdmin(inboxId: String) throws  -> Bool
    
    func listMembers() async throws  -> [FfiConversationMember]
    
    func pausedForVersion() throws  -> String?
    
    func processStreamedConversationMessage(envelopeBytes: Data) async throws  -> FfiMessage
    
    /**
     * Publish all unpublished messages
     */
    func publishMessages() async throws 
    
    func removeAdmin(inboxId: String) async throws 
    
    func removeConversationMessageDisappearingSettings() async throws 
    
    func removeMembers(accountIdentifiers: [FfiIdentifier]) async throws 
    
    func removeMembersByInboxId(inboxIds: [String]) async throws 
    
    func removeSuperAdmin(inboxId: String) async throws 
    
    func send(contentBytes: Data) async throws  -> Data
    
    /**
     * send a message without immediately publishing to the delivery service.
     */
    func sendOptimistic(contentBytes: Data) throws  -> Data
    
    func sendText(text: String) async throws  -> Data
    
    func stream(messageCallback: FfiMessageCallback) async  -> FfiStreamCloser
    
    func superAdminList() throws  -> [String]
    
    func sync() async throws 
    
    func updateConsentState(state: FfiConsentState) throws 
    
    func updateConversationMessageDisappearingSettings(settings: FfiMessageDisappearingSettings) async throws 
    
    func updateGroupDescription(groupDescription: String) async throws 
    
    func updateGroupImageUrlSquare(groupImageUrlSquare: String) async throws 
    
    func updateGroupName(groupName: String) async throws 
    
    func updatePermissionPolicy(permissionUpdateType: FfiPermissionUpdateType, permissionPolicyOption: FfiPermissionPolicy, metadataField: FfiMetadataField?) async throws 
    
}
open class FfiConversation: FfiConversationProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversation(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversation(pointer, $0) }
    }

    

    
open func addAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func addMembers(accountIdentifiers: [FfiIdentifier])async throws  -> FfiUpdateGroupMembershipResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_members(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentifiers)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiUpdateGroupMembershipResult_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func addMembersByInboxId(inboxIds: [String])async throws  -> FfiUpdateGroupMembershipResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_members_by_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiUpdateGroupMembershipResult_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func addSuperAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_add_super_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func addedByInboxId()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_added_by_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func adminList()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_admin_list(self.uniffiClonePointer(),$0
    )
})
}
    
open func consentState()throws  -> FfiConsentState  {
    return try  FfiConverterTypeFfiConsentState_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_consent_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func conversationDebugInfo()async throws  -> FfiConversationDebugInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_conversation_debug_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiConversationDebugInfo_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func conversationMessageDisappearingSettings()throws  -> FfiMessageDisappearingSettings?  {
    return try  FfiConverterOptionTypeFfiMessageDisappearingSettings.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_conversation_message_disappearing_settings(self.uniffiClonePointer(),$0
    )
})
}
    
open func conversationType() -> FfiConversationType  {
    return try!  FfiConverterTypeFfiConversationType_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_conversation_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func createdAtNs() -> Int64  {
    return try!  FfiConverterInt64.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_created_at_ns(self.uniffiClonePointer(),$0
    )
})
}
    
open func dmPeerInboxId() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_dm_peer_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func findDuplicateDms()async throws  -> [FfiConversation]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_find_duplicate_dms(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiConversation.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func findMessages(opts: FfiListMessagesOptions)async throws  -> [FfiMessage]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_find_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiListMessagesOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiMessage.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func findMessagesWithReactions(opts: FfiListMessagesOptions)throws  -> [FfiMessageWithReactions]  {
    return try  FfiConverterSequenceTypeFfiMessageWithReactions.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_find_messages_with_reactions(self.uniffiClonePointer(),
        FfiConverterTypeFfiListMessagesOptions_lower(opts),$0
    )
})
}
    
open func getHmacKeys()throws  -> [Data: [FfiHmacKey]]  {
    return try  FfiConverterDictionaryDataSequenceTypeFfiHmacKey.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_get_hmac_keys(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupDescription()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupImageUrlSquare()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_image_url_square(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupMetadata()async throws  -> FfiConversationMetadata  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_group_metadata(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversationMetadata_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func groupName()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func groupPermissions()throws  -> FfiGroupPermissions  {
    return try  FfiConverterTypeFfiGroupPermissions_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_group_permissions(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversation_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func isActive()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_active(self.uniffiClonePointer(),$0
    )
})
}
    
open func isAdmin(inboxId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_admin(self.uniffiClonePointer(),
        FfiConverterString.lower(inboxId),$0
    )
})
}
    
open func isConversationMessageDisappearingEnabled()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_conversation_message_disappearing_enabled(self.uniffiClonePointer(),$0
    )
})
}
    
open func isSuperAdmin(inboxId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_is_super_admin(self.uniffiClonePointer(),
        FfiConverterString.lower(inboxId),$0
    )
})
}
    
open func listMembers()async throws  -> [FfiConversationMember]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_list_members(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiConversationMember.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func pausedForVersion()throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_paused_for_version(self.uniffiClonePointer(),$0
    )
})
}
    
open func processStreamedConversationMessage(envelopeBytes: Data)async throws  -> FfiMessage  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_process_streamed_conversation_message(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(envelopeBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiMessage_lift,
            errorHandler: FfiConverterTypeFfiSubscribeError_lift
        )
}
    
    /**
     * Publish all unpublished messages
     */
open func publishMessages()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_publish_messages(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func removeAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func removeConversationMessageDisappearingSettings()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_conversation_message_disappearing_settings(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func removeMembers(accountIdentifiers: [FfiIdentifier])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_members(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentifiers)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func removeMembersByInboxId(inboxIds: [String])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_members_by_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func removeSuperAdmin(inboxId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_remove_super_admin(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func send(contentBytes: Data)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_send(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(contentBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * send a message without immediately publishing to the delivery service.
     */
open func sendOptimistic(contentBytes: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_send_optimistic(self.uniffiClonePointer(),
        FfiConverterData.lower(contentBytes),$0
    )
})
}
    
open func sendText(text: String)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_send_text(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(text)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func stream(messageCallback: FfiMessageCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_stream(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func superAdminList()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_super_admin_list(self.uniffiClonePointer(),$0
    )
})
}
    
open func sync()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_sync(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func updateConsentState(state: FfiConsentState)throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversation_update_consent_state(self.uniffiClonePointer(),
        FfiConverterTypeFfiConsentState_lower(state),$0
    )
}
}
    
open func updateConversationMessageDisappearingSettings(settings: FfiMessageDisappearingSettings)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_conversation_message_disappearing_settings(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageDisappearingSettings_lower(settings)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func updateGroupDescription(groupDescription: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_group_description(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(groupDescription)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func updateGroupImageUrlSquare(groupImageUrlSquare: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_group_image_url_square(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(groupImageUrlSquare)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func updateGroupName(groupName: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_group_name(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(groupName)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func updatePermissionPolicy(permissionUpdateType: FfiPermissionUpdateType, permissionPolicyOption: FfiPermissionPolicy, metadataField: FfiMetadataField?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversation_update_permission_policy(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiPermissionUpdateType_lower(permissionUpdateType),FfiConverterTypeFfiPermissionPolicy_lower(permissionPolicyOption),FfiConverterOptionTypeFfiMetadataField.lower(metadataField)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversation: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversation

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversation {
        return FfiConversation(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversation) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversation {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversation, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversation_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversation {
    return try FfiConverterTypeFfiConversation.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversation_lower(_ value: FfiConversation) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversation.lower(value)
}






public protocol FfiConversationCallback: AnyObject, Sendable {
    
    func onConversation(conversation: FfiConversation) 
    
    func onError(error: FfiSubscribeError) 
    
    func onClose() 
    
}
open class FfiConversationCallbackImpl: FfiConversationCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversationcallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversationcallback(pointer, $0) }
    }

    

    
open func onConversation(conversation: FfiConversation)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationcallback_on_conversation(self.uniffiClonePointer(),
        FfiConverterTypeFfiConversation_lower(conversation),$0
    )
}
}
    
open func onError(error: FfiSubscribeError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationcallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiSubscribeError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationcallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiConversationCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiConversationCallback] = [UniffiVTableCallbackInterfaceFfiConversationCallback(
        onConversation: { (
            uniffiHandle: UInt64,
            conversation: UnsafeMutableRawPointer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onConversation(
                     conversation: try FfiConverterTypeFfiConversation_lift(conversation)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiSubscribeError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiConversationCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiConversationCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiConversationCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback(UniffiCallbackInterfaceFfiConversationCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiConversationCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversationCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationCallback {
        return FfiConversationCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversationCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversationCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationCallback {
    return try FfiConverterTypeFfiConversationCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationCallback_lower(_ value: FfiConversationCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversationCallback.lower(value)
}






public protocol FfiConversationListItemProtocol: AnyObject, Sendable {
    
    func conversation()  -> FfiConversation
    
    func isCommitLogForked()  -> Bool?
    
    func lastMessage()  -> FfiMessage?
    
}
open class FfiConversationListItem: FfiConversationListItemProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversationlistitem(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversationlistitem(pointer, $0) }
    }

    

    
open func conversation() -> FfiConversation  {
    return try!  FfiConverterTypeFfiConversation_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationlistitem_conversation(self.uniffiClonePointer(),$0
    )
})
}
    
open func isCommitLogForked() -> Bool?  {
    return try!  FfiConverterOptionBool.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationlistitem_is_commit_log_forked(self.uniffiClonePointer(),$0
    )
})
}
    
open func lastMessage() -> FfiMessage?  {
    return try!  FfiConverterOptionTypeFfiMessage.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationlistitem_last_message(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationListItem: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversationListItem

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationListItem {
        return FfiConversationListItem(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversationListItem) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationListItem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversationListItem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationListItem_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationListItem {
    return try FfiConverterTypeFfiConversationListItem.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationListItem_lower(_ value: FfiConversationListItem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversationListItem.lower(value)
}






public protocol FfiConversationMetadataProtocol: AnyObject, Sendable {
    
    func conversationType()  -> FfiConversationType
    
    func creatorInboxId()  -> String
    
}
open class FfiConversationMetadata: FfiConversationMetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversationmetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversationmetadata(pointer, $0) }
    }

    

    
open func conversationType() -> FfiConversationType  {
    return try!  FfiConverterTypeFfiConversationType_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationmetadata_conversation_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func creatorInboxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_fficonversationmetadata_creator_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversationMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationMetadata {
        return FfiConversationMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversationMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversationMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversationMetadata {
    return try FfiConverterTypeFfiConversationMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMetadata_lower(_ value: FfiConversationMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversationMetadata.lower(value)
}






public protocol FfiConversationsProtocol: AnyObject, Sendable {
    
    func createGroup(accountIdentities: [FfiIdentifier], opts: FfiCreateGroupOptions) async throws  -> FfiConversation
    
    func createGroupOptimistic(opts: FfiCreateGroupOptions) throws  -> FfiConversation
    
    func createGroupWithInboxIds(inboxIds: [String], opts: FfiCreateGroupOptions) async throws  -> FfiConversation
    
    func findOrCreateDm(targetIdentity: FfiIdentifier, opts: FfiCreateDmOptions) async throws  -> FfiConversation
    
    func findOrCreateDmByInboxId(inboxId: String, opts: FfiCreateDmOptions) async throws  -> FfiConversation
    
    func getHmacKeys() throws  -> [Data: [FfiHmacKey]]
    
    func list(opts: FfiListConversationsOptions) throws  -> [FfiConversationListItem]
    
    func listDms(opts: FfiListConversationsOptions) throws  -> [FfiConversationListItem]
    
    func listGroups(opts: FfiListConversationsOptions) throws  -> [FfiConversationListItem]
    
    func processStreamedWelcomeMessage(envelopeBytes: Data) async throws  -> FfiConversation
    
    func stream(callback: FfiConversationCallback) async  -> FfiStreamCloser
    
    func streamAllDmMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    func streamAllGroupMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    func streamAllMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    /**
     * Get notified when there is a new consent update either locally or is synced from another device
     * allowing the user to re-render the new state appropriately
     */
    func streamConsent(callback: FfiConsentCallback) async  -> FfiStreamCloser
    
    func streamDms(callback: FfiConversationCallback) async  -> FfiStreamCloser
    
    func streamGroups(callback: FfiConversationCallback) async  -> FfiStreamCloser
    
    func streamMessages(messageCallback: FfiMessageCallback, conversationType: FfiConversationType?, consentStates: [FfiConsentState]?) async  -> FfiStreamCloser
    
    /**
     * Get notified when a preference changes either locally or is synced from another device
     * allowing the user to re-render the new state appropriately.
     */
    func streamPreferences(callback: FfiPreferenceCallback) async  -> FfiStreamCloser
    
    func sync() async throws 
    
    func syncAllConversations(consentStates: [FfiConsentState]?) async throws  -> UInt32
    
}
open class FfiConversations: FfiConversationsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversations(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversations(pointer, $0) }
    }

    

    
open func createGroup(accountIdentities: [FfiIdentifier], opts: FfiCreateGroupOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_create_group(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentities),FfiConverterTypeFfiCreateGroupOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func createGroupOptimistic(opts: FfiCreateGroupOptions)throws  -> FfiConversation  {
    return try  FfiConverterTypeFfiConversation_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_create_group_optimistic(self.uniffiClonePointer(),
        FfiConverterTypeFfiCreateGroupOptions_lower(opts),$0
    )
})
}
    
open func createGroupWithInboxIds(inboxIds: [String], opts: FfiCreateGroupOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_create_group_with_inbox_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(inboxIds),FfiConverterTypeFfiCreateGroupOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func findOrCreateDm(targetIdentity: FfiIdentifier, opts: FfiCreateDmOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(targetIdentity),FfiConverterTypeFfiCreateDMOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func findOrCreateDmByInboxId(inboxId: String, opts: FfiCreateDmOptions)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm_by_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId),FfiConverterTypeFfiCreateDMOptions_lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func getHmacKeys()throws  -> [Data: [FfiHmacKey]]  {
    return try  FfiConverterDictionaryDataSequenceTypeFfiHmacKey.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_get_hmac_keys(self.uniffiClonePointer(),$0
    )
})
}
    
open func list(opts: FfiListConversationsOptions)throws  -> [FfiConversationListItem]  {
    return try  FfiConverterSequenceTypeFfiConversationListItem.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_list(self.uniffiClonePointer(),
        FfiConverterTypeFfiListConversationsOptions_lower(opts),$0
    )
})
}
    
open func listDms(opts: FfiListConversationsOptions)throws  -> [FfiConversationListItem]  {
    return try  FfiConverterSequenceTypeFfiConversationListItem.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_list_dms(self.uniffiClonePointer(),
        FfiConverterTypeFfiListConversationsOptions_lower(opts),$0
    )
})
}
    
open func listGroups(opts: FfiListConversationsOptions)throws  -> [FfiConversationListItem]  {
    return try  FfiConverterSequenceTypeFfiConversationListItem.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_fficonversations_list_groups(self.uniffiClonePointer(),
        FfiConverterTypeFfiListConversationsOptions_lower(opts),$0
    )
})
}
    
open func processStreamedWelcomeMessage(envelopeBytes: Data)async throws  -> FfiConversation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(envelopeBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiConversation_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func stream(callback: FfiConversationCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConversationCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamAllDmMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_all_dm_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamAllGroupMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_all_group_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamAllMessages(messageCallback: FfiMessageCallback, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get notified when there is a new consent update either locally or is synced from another device
     * allowing the user to re-render the new state appropriately
     */
open func streamConsent(callback: FfiConsentCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_consent(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConsentCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamDms(callback: FfiConversationCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_dms(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConversationCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamGroups(callback: FfiConversationCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_groups(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConversationCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func streamMessages(messageCallback: FfiMessageCallback, conversationType: FfiConversationType?, consentStates: [FfiConsentState]?)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_messages(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiMessageCallback_lower(messageCallback),FfiConverterOptionTypeFfiConversationType.lower(conversationType),FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get notified when a preference changes either locally or is synced from another device
     * allowing the user to re-render the new state appropriately.
     */
open func streamPreferences(callback: FfiPreferenceCallback)async  -> FfiStreamCloser  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream_preferences(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiPreferenceCallback_lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser_lift,
            errorHandler: nil
            
        )
}
    
open func sync()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_sync(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func syncAllConversations(consentStates: [FfiConsentState]?)async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_sync_all_conversations(
                    self.uniffiClonePointer(),
                    FfiConverterOptionSequenceTypeFfiConsentState.lower(consentStates)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_u32,
            completeFunc: ffi_xmtpv3_rust_future_complete_u32,
            freeFunc: ffi_xmtpv3_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversations: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversations

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
        return FfiConversations(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversations {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversations, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversations_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
    return try FfiConverterTypeFfiConversations.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversations_lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversations.lower(value)
}






public protocol FfiGroupPermissionsProtocol: AnyObject, Sendable {
    
    func policySet() throws  -> FfiPermissionPolicySet
    
    func policyType() throws  -> FfiGroupPermissionsOptions
    
}
open class FfiGroupPermissions: FfiGroupPermissionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffigrouppermissions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffigrouppermissions(pointer, $0) }
    }

    

    
open func policySet()throws  -> FfiPermissionPolicySet  {
    return try  FfiConverterTypeFfiPermissionPolicySet_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set(self.uniffiClonePointer(),$0
    )
})
}
    
open func policyType()throws  -> FfiGroupPermissionsOptions  {
    return try  FfiConverterTypeFfiGroupPermissionsOptions_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupPermissions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGroupPermissions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupPermissions {
        return FfiGroupPermissions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGroupPermissions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupPermissions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGroupPermissions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissions_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupPermissions {
    return try FfiConverterTypeFfiGroupPermissions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissions_lower(_ value: FfiGroupPermissions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGroupPermissions.lower(value)
}






public protocol FfiInboxOwner: AnyObject, Sendable {
    
    func getIdentifier() throws  -> FfiIdentifier
    
    func sign(text: String) throws  -> Data
    
}
open class FfiInboxOwnerImpl: FfiInboxOwner, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffiinboxowner(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffiinboxowner(pointer, $0) }
    }

    

    
open func getIdentifier()throws  -> FfiIdentifier  {
    return try  FfiConverterTypeFfiIdentifier_lift(try rustCallWithError(FfiConverterTypeIdentityValidationError_lift) {
    uniffi_xmtpv3_fn_method_ffiinboxowner_get_identifier(self.uniffiClonePointer(),$0
    )
})
}
    
open func sign(text: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSigningError_lift) {
    uniffi_xmtpv3_fn_method_ffiinboxowner_sign(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiInboxOwner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiInboxOwner] = [UniffiVTableCallbackInterfaceFfiInboxOwner(
        getIdentifier: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> FfiIdentifier in
                guard let uniffiObj = try? FfiConverterTypeFfiInboxOwner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.getIdentifier(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeFfiIdentifier_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeIdentityValidationError_lower
            )
        },
        sign: { (
            uniffiHandle: UInt64,
            text: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeFfiInboxOwner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.sign(
                     text: try FfiConverterString.lift(text)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeSigningError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiInboxOwner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiInboxOwner: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiInboxOwner() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner(UniffiCallbackInterfaceFfiInboxOwner.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInboxOwner: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiInboxOwner>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiInboxOwner

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInboxOwner {
        return FfiInboxOwnerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiInboxOwner) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInboxOwner {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiInboxOwner, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxOwner_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiInboxOwner {
    return try FfiConverterTypeFfiInboxOwner.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxOwner_lower(_ value: FfiInboxOwner) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiInboxOwner.lower(value)
}






public protocol FfiMessageCallback: AnyObject, Sendable {
    
    func onMessage(message: FfiMessage) 
    
    func onError(error: FfiSubscribeError) 
    
    func onClose() 
    
}
open class FfiMessageCallbackImpl: FfiMessageCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffimessagecallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffimessagecallback(pointer, $0) }
    }

    

    
open func onMessage(message: FfiMessage)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagecallback_on_message(self.uniffiClonePointer(),
        FfiConverterTypeFfiMessage_lower(message),$0
    )
}
}
    
open func onError(error: FfiSubscribeError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagecallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiSubscribeError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffimessagecallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiMessageCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiMessageCallback] = [UniffiVTableCallbackInterfaceFfiMessageCallback(
        onMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onMessage(
                     message: try FfiConverterTypeFfiMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiSubscribeError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiMessageCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiMessageCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiMessageCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback(UniffiCallbackInterfaceFfiMessageCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiMessageCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiMessageCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiMessageCallback {
        return FfiMessageCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiMessageCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiMessageCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiMessageCallback {
    return try FfiConverterTypeFfiMessageCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageCallback_lower(_ value: FfiMessageCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiMessageCallback.lower(value)
}






public protocol FfiPreferenceCallback: AnyObject, Sendable {
    
    func onPreferenceUpdate(preference: [FfiPreferenceUpdate]) 
    
    func onError(error: FfiSubscribeError) 
    
    func onClose() 
    
}
open class FfiPreferenceCallbackImpl: FfiPreferenceCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffipreferencecallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffipreferencecallback(pointer, $0) }
    }

    

    
open func onPreferenceUpdate(preference: [FfiPreferenceUpdate])  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffipreferencecallback_on_preference_update(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFfiPreferenceUpdate.lower(preference),$0
    )
}
}
    
open func onError(error: FfiSubscribeError)  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffipreferencecallback_on_error(self.uniffiClonePointer(),
        FfiConverterTypeFfiSubscribeError_lower(error),$0
    )
}
}
    
open func onClose()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffipreferencecallback_on_close(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiPreferenceCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiPreferenceCallback] = [UniffiVTableCallbackInterfaceFfiPreferenceCallback(
        onPreferenceUpdate: { (
            uniffiHandle: UInt64,
            preference: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiPreferenceCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPreferenceUpdate(
                     preference: try FfiConverterSequenceTypeFfiPreferenceUpdate.lift(preference)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onError: { (
            uniffiHandle: UInt64,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiPreferenceCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     error: try FfiConverterTypeFfiSubscribeError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onClose: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFfiPreferenceCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onClose(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFfiPreferenceCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiPreferenceCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFfiPreferenceCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffipreferencecallback(UniffiCallbackInterfaceFfiPreferenceCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPreferenceCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FfiPreferenceCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiPreferenceCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiPreferenceCallback {
        return FfiPreferenceCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiPreferenceCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPreferenceCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiPreferenceCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiPreferenceCallback {
    return try FfiConverterTypeFfiPreferenceCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceCallback_lower(_ value: FfiPreferenceCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiPreferenceCallback.lower(value)
}






public protocol FfiSignatureRequestProtocol: AnyObject, Sendable {
    
    func addEcdsaSignature(signatureBytes: Data) async throws 
    
    func addPasskeySignature(signature: FfiPasskeySignature) async throws 
    
    func addScwSignature(signatureBytes: Data, address: String, chainId: UInt64, blockNumber: UInt64?) async throws 
    
    func isReady() async  -> Bool
    
    /**
     * missing signatures that are from [MemberKind::Address]
     */
    func missingAddressSignatures() async throws  -> [String]
    
    func signatureText() async throws  -> String
    
}
open class FfiSignatureRequest: FfiSignatureRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffisignaturerequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffisignaturerequest(pointer, $0) }
    }

    

    
open func addEcdsaSignature(signatureBytes: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(signatureBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func addPasskeySignature(signature: FfiPasskeySignature)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_add_passkey_signature(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiPasskeySignature_lower(signature)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func addScwSignature(signatureBytes: Data, address: String, chainId: UInt64, blockNumber: UInt64?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(signatureBytes),FfiConverterString.lower(address),FfiConverterUInt64.lower(chainId),FfiConverterOptionUInt64.lower(blockNumber)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func isReady()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_i8,
            completeFunc: ffi_xmtpv3_rust_future_complete_i8,
            freeFunc: ffi_xmtpv3_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * missing signatures that are from [MemberKind::Address]
     */
open func missingAddressSignatures()async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func signatureText()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSignatureRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiSignatureRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSignatureRequest {
        return FfiSignatureRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiSignatureRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSignatureRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiSignatureRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignatureRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSignatureRequest {
    return try FfiConverterTypeFfiSignatureRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignatureRequest_lower(_ value: FfiSignatureRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiSignatureRequest.lower(value)
}






public protocol FfiStreamCloserProtocol: AnyObject, Sendable {
    
    /**
     * Signal the stream to end
     * Does not wait for the stream to end.
     */
    func end() 
    
    /**
     * End the stream and asynchronously wait for it to shutdown
     */
    func endAndWait() async throws 
    
    func isClosed()  -> Bool
    
    func waitForReady() async 
    
}
open class FfiStreamCloser: FfiStreamCloserProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffistreamcloser(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffistreamcloser(pointer, $0) }
    }

    

    
    /**
     * Signal the stream to end
     * Does not wait for the stream to end.
     */
open func end()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffistreamcloser_end(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * End the stream and asynchronously wait for it to shutdown
     */
open func endAndWait()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func isClosed() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed(self.uniffiClonePointer(),$0
    )
})
}
    
open func waitForReady()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffistreamcloser_wait_for_ready(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiStreamCloser: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiStreamCloser

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
        return FfiStreamCloser(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiStreamCloser {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiStreamCloser, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiStreamCloser_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
    return try FfiConverterTypeFfiStreamCloser.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiStreamCloser_lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiStreamCloser.lower(value)
}






public protocol FfiSyncWorkerProtocol: AnyObject, Sendable {
    
    func wait(metric: FfiSyncMetric, count: UInt64) async throws 
    
}
open class FfiSyncWorker: FfiSyncWorkerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffisyncworker(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffisyncworker(pointer, $0) }
    }

    

    
open func wait(metric: FfiSyncMetric, count: UInt64)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffisyncworker_wait(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiSyncMetric_lower(metric),FfiConverterUInt64.lower(count)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSyncWorker: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiSyncWorker

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSyncWorker {
        return FfiSyncWorker(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiSyncWorker) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSyncWorker {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiSyncWorker, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncWorker_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSyncWorker {
    return try FfiConverterTypeFfiSyncWorker.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncWorker_lower(_ value: FfiSyncWorker) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiSyncWorker.lower(value)
}






public protocol FfiXmtpClientProtocol: AnyObject, Sendable {
    
    /**
     * Adds a wallet address to the existing client
     */
    func addIdentity(newIdentity: FfiIdentifier) async throws  -> FfiSignatureRequest
    
    /**
     * * Get the inbox state for each `inbox_id`.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
    func addressesFromInboxId(refreshFromNetwork: Bool, inboxIds: [String]) async throws  -> [FfiInboxState]
    
    func apiAggregateStatistics()  -> String
    
    func apiIdentityStatistics()  -> FfiIdentityStats
    
    func apiStatistics()  -> FfiApiStats
    
    func applySignatureRequest(signatureRequest: FfiSignatureRequest) async throws 
    
    /**
     * Load the metadata for an archive to see what it contains.
     * Reads only the metadata without loading the entire file, so this function is quick.
     */
    func archiveMetadata(path: String, key: Data) async throws  -> FfiBackupMetadata
    
    func canMessage(accountIdentifiers: [FfiIdentifier]) async throws  -> [FfiIdentifier: Bool]
    
    /**
     * * Change the recovery identifier for your inboxId
     */
    func changeRecoveryIdentifier(newRecoveryIdentifier: FfiIdentifier) async throws  -> FfiSignatureRequest
    
    func clearAllStatistics() 
    
    func conversation(conversationId: Data) throws  -> FfiConversation
    
    func conversations()  -> FfiConversations
    
    /**
     * Archive application elements to file for later restoration.
     */
    func createArchive(path: String, opts: FfiArchiveOptions, key: Data) async throws 
    
    func dbReconnect() async throws 
    
    func dmConversation(targetInboxId: String) throws  -> FfiConversation
    
    func findInboxId(identifier: FfiIdentifier) async throws  -> String?
    
    func getConsentState(entityType: FfiConsentEntityType, entity: String) async throws  -> FfiConsentState
    
    func getKeyPackageStatusesForInstallationIds(installationIds: [Data]) async throws  -> [Data: FfiKeyPackageStatus]
    
    func getLatestInboxState(inboxId: String) async throws  -> FfiInboxState
    
    /**
     * Import a previous archive
     */
    func importArchive(path: String, key: Data) async throws 
    
    func inboxId()  -> String
    
    /**
     * * Get the client's inbox state.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
    func inboxState(refreshFromNetwork: Bool) async throws  -> FfiInboxState
    
    func installationId()  -> Data
    
    func message(messageId: Data) throws  -> FfiMessage
    
    func registerIdentity(signatureRequest: FfiSignatureRequest) async throws 
    
    func releaseDbConnection() throws 
    
    /**
     * * Revokes all installations except the one the client is currently using
     */
    func revokeAllOtherInstallations() async throws  -> FfiSignatureRequest
    
    /**
     * Revokes or removes an identity from the existing client
     */
    func revokeIdentity(identifier: FfiIdentifier) async throws  -> FfiSignatureRequest
    
    /**
     * * Revoke a list of installations
     */
    func revokeInstallations(installationIds: [Data]) async throws  -> FfiSignatureRequest
    
    /**
     * Manually trigger a device sync request to sync records from another active device on this account.
     */
    func sendSyncRequest() async throws 
    
    func setConsentStates(records: [FfiConsent]) async throws 
    
    /**
     * A utility function to sign a piece of text with this installation's private key.
     */
    func signWithInstallationKey(text: String) throws  -> Data
    
    func signatureRequest()  -> FfiSignatureRequest?
    
    func syncPreferences() async throws  -> UInt64
    
    /**
     * Export an encrypted debug archive to a device sync server to inspect telemetry for debugging purposes.
     */
    func uploadDebugArchive(serverUrl: String) async throws  -> String
    
    /**
     * A utility function to easily verify that a piece of text was signed by this installation.
     */
    func verifySignedWithInstallationKey(signatureText: String, signatureBytes: Data) throws 
    
    /**
     * A utility function to easily verify that a string has been signed by another libXmtp installation.
     * Only works for verifying libXmtp public context signatures.
     */
    func verifySignedWithPublicKey(signatureText: String, signatureBytes: Data, publicKey: Data) throws 
    
}
open class FfiXmtpClient: FfiXmtpClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffixmtpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffixmtpclient(pointer, $0) }
    }

    

    
    /**
     * Adds a wallet address to the existing client
     */
open func addIdentity(newIdentity: FfiIdentifier)async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_add_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(newIdentity)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * * Get the inbox state for each `inbox_id`.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
open func addressesFromInboxId(refreshFromNetwork: Bool, inboxIds: [String])async throws  -> [FfiInboxState]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_addresses_from_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(refreshFromNetwork),FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiInboxState.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func apiAggregateStatistics() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_api_aggregate_statistics(self.uniffiClonePointer(),$0
    )
})
}
    
open func apiIdentityStatistics() -> FfiIdentityStats  {
    return try!  FfiConverterTypeFfiIdentityStats_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_api_identity_statistics(self.uniffiClonePointer(),$0
    )
})
}
    
open func apiStatistics() -> FfiApiStats  {
    return try!  FfiConverterTypeFfiApiStats_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_api_statistics(self.uniffiClonePointer(),$0
    )
})
}
    
open func applySignatureRequest(signatureRequest: FfiSignatureRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiSignatureRequest_lower(signatureRequest)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * Load the metadata for an archive to see what it contains.
     * Reads only the metadata without loading the entire file, so this function is quick.
     */
open func archiveMetadata(path: String, key: Data)async throws  -> FfiBackupMetadata  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_archive_metadata(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterData.lower(key)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiBackupMetadata_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func canMessage(accountIdentifiers: [FfiIdentifier])async throws  -> [FfiIdentifier: Bool]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_can_message(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiIdentifier.lower(accountIdentifiers)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeFfiIdentifierBool.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * * Change the recovery identifier for your inboxId
     */
open func changeRecoveryIdentifier(newRecoveryIdentifier: FfiIdentifier)async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_change_recovery_identifier(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(newRecoveryIdentifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func clearAllStatistics()  {try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_clear_all_statistics(self.uniffiClonePointer(),$0
    )
}
}
    
open func conversation(conversationId: Data)throws  -> FfiConversation  {
    return try  FfiConverterTypeFfiConversation_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_conversation(self.uniffiClonePointer(),
        FfiConverterData.lower(conversationId),$0
    )
})
}
    
open func conversations() -> FfiConversations  {
    return try!  FfiConverterTypeFfiConversations_lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_conversations(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Archive application elements to file for later restoration.
     */
open func createArchive(path: String, opts: FfiArchiveOptions, key: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_create_archive(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterTypeFfiArchiveOptions_lower(opts),FfiConverterData.lower(key)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func dbReconnect()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func dmConversation(targetInboxId: String)throws  -> FfiConversation  {
    return try  FfiConverterTypeFfiConversation_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_dm_conversation(self.uniffiClonePointer(),
        FfiConverterString.lower(targetInboxId),$0
    )
})
}
    
open func findInboxId(identifier: FfiIdentifier)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(identifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func getConsentState(entityType: FfiConsentEntityType, entity: String)async throws  -> FfiConsentState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiConsentEntityType_lower(entityType),FfiConverterString.lower(entity)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiConsentState_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func getKeyPackageStatusesForInstallationIds(installationIds: [Data])async throws  -> [Data: FfiKeyPackageStatus]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_get_key_package_statuses_for_installation_ids(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceData.lower(installationIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryDataTypeFfiKeyPackageStatus.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func getLatestInboxState(inboxId: String)async throws  -> FfiInboxState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(inboxId)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiInboxState_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * Import a previous archive
     */
open func importArchive(path: String, key: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_import_archive(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterData.lower(key)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func inboxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * * Get the client's inbox state.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
open func inboxState(refreshFromNetwork: Bool)async throws  -> FfiInboxState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state(
                    self.uniffiClonePointer(),
                    FfiConverterBool.lower(refreshFromNetwork)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiInboxState_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func installationId() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func message(messageId: Data)throws  -> FfiMessage  {
    return try  FfiConverterTypeFfiMessage_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_message(self.uniffiClonePointer(),
        FfiConverterData.lower(messageId),$0
    )
})
}
    
open func registerIdentity(signatureRequest: FfiSignatureRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiSignatureRequest_lower(signatureRequest)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func releaseDbConnection()throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * * Revokes all installations except the one the client is currently using
     */
open func revokeAllOtherInstallations()async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * Revokes or removes an identity from the existing client
     */
open func revokeIdentity(identifier: FfiIdentifier)async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_identity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFfiIdentifier_lower(identifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * * Revoke a list of installations
     */
open func revokeInstallations(installationIds: [Data])async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_installations(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceData.lower(installationIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * Manually trigger a device sync request to sync records from another active device on this account.
     */
open func sendSyncRequest()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_request(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
open func setConsentStates(records: [FfiConsent])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_states(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFfiConsent.lower(records)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * A utility function to sign a piece of text with this installation's private key.
     */
open func signWithInstallationKey(text: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_sign_with_installation_key(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    
open func signatureRequest() -> FfiSignatureRequest?  {
    return try!  FfiConverterOptionTypeFfiSignatureRequest.lift(try! rustCall() {
    uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request(self.uniffiClonePointer(),$0
    )
})
}
    
open func syncPreferences()async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_sync_preferences(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_u64,
            completeFunc: ffi_xmtpv3_rust_future_complete_u64,
            freeFunc: ffi_xmtpv3_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * Export an encrypted debug archive to a device sync server to inspect telemetry for debugging purposes.
     */
open func uploadDebugArchive(serverUrl: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_upload_debug_archive(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(serverUrl)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
    
    /**
     * A utility function to easily verify that a piece of text was signed by this installation.
     */
open func verifySignedWithInstallationKey(signatureText: String, signatureBytes: Data)throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_installation_key(self.uniffiClonePointer(),
        FfiConverterString.lower(signatureText),
        FfiConverterData.lower(signatureBytes),$0
    )
}
}
    
    /**
     * A utility function to easily verify that a string has been signed by another libXmtp installation.
     * Only works for verifying libXmtp public context signatures.
     */
open func verifySignedWithPublicKey(signatureText: String, signatureBytes: Data, publicKey: Data)throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_public_key(self.uniffiClonePointer(),
        FfiConverterString.lower(signatureText),
        FfiConverterData.lower(signatureBytes),
        FfiConverterData.lower(publicKey),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiXmtpClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiXmtpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
        return FfiXmtpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiXmtpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiXmtpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiXmtpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
    return try FfiConverterTypeFfiXmtpClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiXmtpClient_lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiXmtpClient.lower(value)
}






public protocol XmtpApiClientProtocol: AnyObject, Sendable {
    
}
open class XmtpApiClient: XmtpApiClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_xmtpapiclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_xmtpapiclient(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeXmtpApiClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = XmtpApiClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> XmtpApiClient {
        return XmtpApiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: XmtpApiClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> XmtpApiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: XmtpApiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXmtpApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> XmtpApiClient {
    return try FfiConverterTypeXmtpApiClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXmtpApiClient_lower(_ value: XmtpApiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeXmtpApiClient.lower(value)
}




public struct FfiApiStats {
    public var uploadKeyPackage: UInt64
    public var fetchKeyPackage: UInt64
    public var sendGroupMessages: UInt64
    public var sendWelcomeMessages: UInt64
    public var queryGroupMessages: UInt64
    public var queryWelcomeMessages: UInt64
    public var subscribeMessages: UInt64
    public var subscribeWelcomes: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uploadKeyPackage: UInt64, fetchKeyPackage: UInt64, sendGroupMessages: UInt64, sendWelcomeMessages: UInt64, queryGroupMessages: UInt64, queryWelcomeMessages: UInt64, subscribeMessages: UInt64, subscribeWelcomes: UInt64) {
        self.uploadKeyPackage = uploadKeyPackage
        self.fetchKeyPackage = fetchKeyPackage
        self.sendGroupMessages = sendGroupMessages
        self.sendWelcomeMessages = sendWelcomeMessages
        self.queryGroupMessages = queryGroupMessages
        self.queryWelcomeMessages = queryWelcomeMessages
        self.subscribeMessages = subscribeMessages
        self.subscribeWelcomes = subscribeWelcomes
    }
}

#if compiler(>=6)
extension FfiApiStats: Sendable {}
#endif


extension FfiApiStats: Equatable, Hashable {
    public static func ==(lhs: FfiApiStats, rhs: FfiApiStats) -> Bool {
        if lhs.uploadKeyPackage != rhs.uploadKeyPackage {
            return false
        }
        if lhs.fetchKeyPackage != rhs.fetchKeyPackage {
            return false
        }
        if lhs.sendGroupMessages != rhs.sendGroupMessages {
            return false
        }
        if lhs.sendWelcomeMessages != rhs.sendWelcomeMessages {
            return false
        }
        if lhs.queryGroupMessages != rhs.queryGroupMessages {
            return false
        }
        if lhs.queryWelcomeMessages != rhs.queryWelcomeMessages {
            return false
        }
        if lhs.subscribeMessages != rhs.subscribeMessages {
            return false
        }
        if lhs.subscribeWelcomes != rhs.subscribeWelcomes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadKeyPackage)
        hasher.combine(fetchKeyPackage)
        hasher.combine(sendGroupMessages)
        hasher.combine(sendWelcomeMessages)
        hasher.combine(queryGroupMessages)
        hasher.combine(queryWelcomeMessages)
        hasher.combine(subscribeMessages)
        hasher.combine(subscribeWelcomes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiApiStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiApiStats {
        return
            try FfiApiStats(
                uploadKeyPackage: FfiConverterUInt64.read(from: &buf), 
                fetchKeyPackage: FfiConverterUInt64.read(from: &buf), 
                sendGroupMessages: FfiConverterUInt64.read(from: &buf), 
                sendWelcomeMessages: FfiConverterUInt64.read(from: &buf), 
                queryGroupMessages: FfiConverterUInt64.read(from: &buf), 
                queryWelcomeMessages: FfiConverterUInt64.read(from: &buf), 
                subscribeMessages: FfiConverterUInt64.read(from: &buf), 
                subscribeWelcomes: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiApiStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.uploadKeyPackage, into: &buf)
        FfiConverterUInt64.write(value.fetchKeyPackage, into: &buf)
        FfiConverterUInt64.write(value.sendGroupMessages, into: &buf)
        FfiConverterUInt64.write(value.sendWelcomeMessages, into: &buf)
        FfiConverterUInt64.write(value.queryGroupMessages, into: &buf)
        FfiConverterUInt64.write(value.queryWelcomeMessages, into: &buf)
        FfiConverterUInt64.write(value.subscribeMessages, into: &buf)
        FfiConverterUInt64.write(value.subscribeWelcomes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApiStats_lift(_ buf: RustBuffer) throws -> FfiApiStats {
    return try FfiConverterTypeFfiApiStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApiStats_lower(_ value: FfiApiStats) -> RustBuffer {
    return FfiConverterTypeFfiApiStats.lower(value)
}


public struct FfiArchiveOptions {
    public var startNs: Int64?
    public var endNs: Int64?
    public var elements: [FfiBackupElementSelection]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(startNs: Int64?, endNs: Int64?, elements: [FfiBackupElementSelection]) {
        self.startNs = startNs
        self.endNs = endNs
        self.elements = elements
    }
}

#if compiler(>=6)
extension FfiArchiveOptions: Sendable {}
#endif


extension FfiArchiveOptions: Equatable, Hashable {
    public static func ==(lhs: FfiArchiveOptions, rhs: FfiArchiveOptions) -> Bool {
        if lhs.startNs != rhs.startNs {
            return false
        }
        if lhs.endNs != rhs.endNs {
            return false
        }
        if lhs.elements != rhs.elements {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(startNs)
        hasher.combine(endNs)
        hasher.combine(elements)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiArchiveOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiArchiveOptions {
        return
            try FfiArchiveOptions(
                startNs: FfiConverterOptionInt64.read(from: &buf), 
                endNs: FfiConverterOptionInt64.read(from: &buf), 
                elements: FfiConverterSequenceTypeFfiBackupElementSelection.read(from: &buf)
        )
    }

    public static func write(_ value: FfiArchiveOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.startNs, into: &buf)
        FfiConverterOptionInt64.write(value.endNs, into: &buf)
        FfiConverterSequenceTypeFfiBackupElementSelection.write(value.elements, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiArchiveOptions_lift(_ buf: RustBuffer) throws -> FfiArchiveOptions {
    return try FfiConverterTypeFfiArchiveOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiArchiveOptions_lower(_ value: FfiArchiveOptions) -> RustBuffer {
    return FfiConverterTypeFfiArchiveOptions.lower(value)
}


public struct FfiBackupMetadata {
    public var backupVersion: UInt16
    public var elements: [FfiBackupElementSelection]
    public var exportedAtNs: Int64
    public var startNs: Int64?
    public var endNs: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backupVersion: UInt16, elements: [FfiBackupElementSelection], exportedAtNs: Int64, startNs: Int64?, endNs: Int64?) {
        self.backupVersion = backupVersion
        self.elements = elements
        self.exportedAtNs = exportedAtNs
        self.startNs = startNs
        self.endNs = endNs
    }
}

#if compiler(>=6)
extension FfiBackupMetadata: Sendable {}
#endif


extension FfiBackupMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiBackupMetadata, rhs: FfiBackupMetadata) -> Bool {
        if lhs.backupVersion != rhs.backupVersion {
            return false
        }
        if lhs.elements != rhs.elements {
            return false
        }
        if lhs.exportedAtNs != rhs.exportedAtNs {
            return false
        }
        if lhs.startNs != rhs.startNs {
            return false
        }
        if lhs.endNs != rhs.endNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backupVersion)
        hasher.combine(elements)
        hasher.combine(exportedAtNs)
        hasher.combine(startNs)
        hasher.combine(endNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiBackupMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBackupMetadata {
        return
            try FfiBackupMetadata(
                backupVersion: FfiConverterUInt16.read(from: &buf), 
                elements: FfiConverterSequenceTypeFfiBackupElementSelection.read(from: &buf), 
                exportedAtNs: FfiConverterInt64.read(from: &buf), 
                startNs: FfiConverterOptionInt64.read(from: &buf), 
                endNs: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiBackupMetadata, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.backupVersion, into: &buf)
        FfiConverterSequenceTypeFfiBackupElementSelection.write(value.elements, into: &buf)
        FfiConverterInt64.write(value.exportedAtNs, into: &buf)
        FfiConverterOptionInt64.write(value.startNs, into: &buf)
        FfiConverterOptionInt64.write(value.endNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupMetadata_lift(_ buf: RustBuffer) throws -> FfiBackupMetadata {
    return try FfiConverterTypeFfiBackupMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupMetadata_lower(_ value: FfiBackupMetadata) -> RustBuffer {
    return FfiConverterTypeFfiBackupMetadata.lower(value)
}


public struct FfiConsent {
    public var entityType: FfiConsentEntityType
    public var state: FfiConsentState
    public var entity: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entityType: FfiConsentEntityType, state: FfiConsentState, entity: String) {
        self.entityType = entityType
        self.state = state
        self.entity = entity
    }
}

#if compiler(>=6)
extension FfiConsent: Sendable {}
#endif


extension FfiConsent: Equatable, Hashable {
    public static func ==(lhs: FfiConsent, rhs: FfiConsent) -> Bool {
        if lhs.entityType != rhs.entityType {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.entity != rhs.entity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entityType)
        hasher.combine(state)
        hasher.combine(entity)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsent {
        return
            try FfiConsent(
                entityType: FfiConverterTypeFfiConsentEntityType.read(from: &buf), 
                state: FfiConverterTypeFfiConsentState.read(from: &buf), 
                entity: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiConsent, into buf: inout [UInt8]) {
        FfiConverterTypeFfiConsentEntityType.write(value.entityType, into: &buf)
        FfiConverterTypeFfiConsentState.write(value.state, into: &buf)
        FfiConverterString.write(value.entity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsent_lift(_ buf: RustBuffer) throws -> FfiConsent {
    return try FfiConverterTypeFfiConsent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsent_lower(_ value: FfiConsent) -> RustBuffer {
    return FfiConverterTypeFfiConsent.lower(value)
}


public struct FfiConversationDebugInfo {
    public var epoch: UInt64
    public var maybeForked: Bool
    public var forkDetails: String
    public var isCommitLogForked: Bool?
    public var localCommitLog: String
    public var remoteCommitLog: String
    public var cursor: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(epoch: UInt64, maybeForked: Bool, forkDetails: String, isCommitLogForked: Bool?, localCommitLog: String, remoteCommitLog: String, cursor: Int64) {
        self.epoch = epoch
        self.maybeForked = maybeForked
        self.forkDetails = forkDetails
        self.isCommitLogForked = isCommitLogForked
        self.localCommitLog = localCommitLog
        self.remoteCommitLog = remoteCommitLog
        self.cursor = cursor
    }
}

#if compiler(>=6)
extension FfiConversationDebugInfo: Sendable {}
#endif


extension FfiConversationDebugInfo: Equatable, Hashable {
    public static func ==(lhs: FfiConversationDebugInfo, rhs: FfiConversationDebugInfo) -> Bool {
        if lhs.epoch != rhs.epoch {
            return false
        }
        if lhs.maybeForked != rhs.maybeForked {
            return false
        }
        if lhs.forkDetails != rhs.forkDetails {
            return false
        }
        if lhs.isCommitLogForked != rhs.isCommitLogForked {
            return false
        }
        if lhs.localCommitLog != rhs.localCommitLog {
            return false
        }
        if lhs.remoteCommitLog != rhs.remoteCommitLog {
            return false
        }
        if lhs.cursor != rhs.cursor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(epoch)
        hasher.combine(maybeForked)
        hasher.combine(forkDetails)
        hasher.combine(isCommitLogForked)
        hasher.combine(localCommitLog)
        hasher.combine(remoteCommitLog)
        hasher.combine(cursor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationDebugInfo {
        return
            try FfiConversationDebugInfo(
                epoch: FfiConverterUInt64.read(from: &buf), 
                maybeForked: FfiConverterBool.read(from: &buf), 
                forkDetails: FfiConverterString.read(from: &buf), 
                isCommitLogForked: FfiConverterOptionBool.read(from: &buf), 
                localCommitLog: FfiConverterString.read(from: &buf), 
                remoteCommitLog: FfiConverterString.read(from: &buf), 
                cursor: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiConversationDebugInfo, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterBool.write(value.maybeForked, into: &buf)
        FfiConverterString.write(value.forkDetails, into: &buf)
        FfiConverterOptionBool.write(value.isCommitLogForked, into: &buf)
        FfiConverterString.write(value.localCommitLog, into: &buf)
        FfiConverterString.write(value.remoteCommitLog, into: &buf)
        FfiConverterInt64.write(value.cursor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationDebugInfo_lift(_ buf: RustBuffer) throws -> FfiConversationDebugInfo {
    return try FfiConverterTypeFfiConversationDebugInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationDebugInfo_lower(_ value: FfiConversationDebugInfo) -> RustBuffer {
    return FfiConverterTypeFfiConversationDebugInfo.lower(value)
}


public struct FfiConversationMember {
    public var inboxId: String
    public var accountIdentifiers: [FfiIdentifier]
    public var installationIds: [Data]
    public var permissionLevel: FfiPermissionLevel
    public var consentState: FfiConsentState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String, accountIdentifiers: [FfiIdentifier], installationIds: [Data], permissionLevel: FfiPermissionLevel, consentState: FfiConsentState) {
        self.inboxId = inboxId
        self.accountIdentifiers = accountIdentifiers
        self.installationIds = installationIds
        self.permissionLevel = permissionLevel
        self.consentState = consentState
    }
}

#if compiler(>=6)
extension FfiConversationMember: Sendable {}
#endif


extension FfiConversationMember: Equatable, Hashable {
    public static func ==(lhs: FfiConversationMember, rhs: FfiConversationMember) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        if lhs.accountIdentifiers != rhs.accountIdentifiers {
            return false
        }
        if lhs.installationIds != rhs.installationIds {
            return false
        }
        if lhs.permissionLevel != rhs.permissionLevel {
            return false
        }
        if lhs.consentState != rhs.consentState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
        hasher.combine(accountIdentifiers)
        hasher.combine(installationIds)
        hasher.combine(permissionLevel)
        hasher.combine(consentState)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationMember {
        return
            try FfiConversationMember(
                inboxId: FfiConverterString.read(from: &buf), 
                accountIdentifiers: FfiConverterSequenceTypeFfiIdentifier.read(from: &buf), 
                installationIds: FfiConverterSequenceData.read(from: &buf), 
                permissionLevel: FfiConverterTypeFfiPermissionLevel.read(from: &buf), 
                consentState: FfiConverterTypeFfiConsentState.read(from: &buf)
        )
    }

    public static func write(_ value: FfiConversationMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
        FfiConverterSequenceTypeFfiIdentifier.write(value.accountIdentifiers, into: &buf)
        FfiConverterSequenceData.write(value.installationIds, into: &buf)
        FfiConverterTypeFfiPermissionLevel.write(value.permissionLevel, into: &buf)
        FfiConverterTypeFfiConsentState.write(value.consentState, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMember_lift(_ buf: RustBuffer) throws -> FfiConversationMember {
    return try FfiConverterTypeFfiConversationMember.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMember_lower(_ value: FfiConversationMember) -> RustBuffer {
    return FfiConverterTypeFfiConversationMember.lower(value)
}


public struct FfiCreateDmOptions {
    public var messageDisappearingSettings: FfiMessageDisappearingSettings?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageDisappearingSettings: FfiMessageDisappearingSettings?) {
        self.messageDisappearingSettings = messageDisappearingSettings
    }
}

#if compiler(>=6)
extension FfiCreateDmOptions: Sendable {}
#endif


extension FfiCreateDmOptions: Equatable, Hashable {
    public static func ==(lhs: FfiCreateDmOptions, rhs: FfiCreateDmOptions) -> Bool {
        if lhs.messageDisappearingSettings != rhs.messageDisappearingSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageDisappearingSettings)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCreateDMOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCreateDmOptions {
        return
            try FfiCreateDmOptions(
                messageDisappearingSettings: FfiConverterOptionTypeFfiMessageDisappearingSettings.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCreateDmOptions, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiMessageDisappearingSettings.write(value.messageDisappearingSettings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateDMOptions_lift(_ buf: RustBuffer) throws -> FfiCreateDmOptions {
    return try FfiConverterTypeFfiCreateDMOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateDMOptions_lower(_ value: FfiCreateDmOptions) -> RustBuffer {
    return FfiConverterTypeFfiCreateDMOptions.lower(value)
}


public struct FfiCreateGroupOptions {
    public var permissions: FfiGroupPermissionsOptions?
    public var groupName: String?
    public var groupImageUrlSquare: String?
    public var groupDescription: String?
    public var customPermissionPolicySet: FfiPermissionPolicySet?
    public var messageDisappearingSettings: FfiMessageDisappearingSettings?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(permissions: FfiGroupPermissionsOptions?, groupName: String?, groupImageUrlSquare: String?, groupDescription: String?, customPermissionPolicySet: FfiPermissionPolicySet?, messageDisappearingSettings: FfiMessageDisappearingSettings?) {
        self.permissions = permissions
        self.groupName = groupName
        self.groupImageUrlSquare = groupImageUrlSquare
        self.groupDescription = groupDescription
        self.customPermissionPolicySet = customPermissionPolicySet
        self.messageDisappearingSettings = messageDisappearingSettings
    }
}

#if compiler(>=6)
extension FfiCreateGroupOptions: Sendable {}
#endif


extension FfiCreateGroupOptions: Equatable, Hashable {
    public static func ==(lhs: FfiCreateGroupOptions, rhs: FfiCreateGroupOptions) -> Bool {
        if lhs.permissions != rhs.permissions {
            return false
        }
        if lhs.groupName != rhs.groupName {
            return false
        }
        if lhs.groupImageUrlSquare != rhs.groupImageUrlSquare {
            return false
        }
        if lhs.groupDescription != rhs.groupDescription {
            return false
        }
        if lhs.customPermissionPolicySet != rhs.customPermissionPolicySet {
            return false
        }
        if lhs.messageDisappearingSettings != rhs.messageDisappearingSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(permissions)
        hasher.combine(groupName)
        hasher.combine(groupImageUrlSquare)
        hasher.combine(groupDescription)
        hasher.combine(customPermissionPolicySet)
        hasher.combine(messageDisappearingSettings)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCreateGroupOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCreateGroupOptions {
        return
            try FfiCreateGroupOptions(
                permissions: FfiConverterOptionTypeFfiGroupPermissionsOptions.read(from: &buf), 
                groupName: FfiConverterOptionString.read(from: &buf), 
                groupImageUrlSquare: FfiConverterOptionString.read(from: &buf), 
                groupDescription: FfiConverterOptionString.read(from: &buf), 
                customPermissionPolicySet: FfiConverterOptionTypeFfiPermissionPolicySet.read(from: &buf), 
                messageDisappearingSettings: FfiConverterOptionTypeFfiMessageDisappearingSettings.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCreateGroupOptions, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiGroupPermissionsOptions.write(value.permissions, into: &buf)
        FfiConverterOptionString.write(value.groupName, into: &buf)
        FfiConverterOptionString.write(value.groupImageUrlSquare, into: &buf)
        FfiConverterOptionString.write(value.groupDescription, into: &buf)
        FfiConverterOptionTypeFfiPermissionPolicySet.write(value.customPermissionPolicySet, into: &buf)
        FfiConverterOptionTypeFfiMessageDisappearingSettings.write(value.messageDisappearingSettings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateGroupOptions_lift(_ buf: RustBuffer) throws -> FfiCreateGroupOptions {
    return try FfiConverterTypeFfiCreateGroupOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCreateGroupOptions_lower(_ value: FfiCreateGroupOptions) -> RustBuffer {
    return FfiConverterTypeFfiCreateGroupOptions.lower(value)
}


public struct FfiHmacKey {
    public var key: Data
    public var epoch: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: Data, epoch: Int64) {
        self.key = key
        self.epoch = epoch
    }
}

#if compiler(>=6)
extension FfiHmacKey: Sendable {}
#endif


extension FfiHmacKey: Equatable, Hashable {
    public static func ==(lhs: FfiHmacKey, rhs: FfiHmacKey) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.epoch != rhs.epoch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(epoch)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiHmacKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiHmacKey {
        return
            try FfiHmacKey(
                key: FfiConverterData.read(from: &buf), 
                epoch: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiHmacKey, into buf: inout [UInt8]) {
        FfiConverterData.write(value.key, into: &buf)
        FfiConverterInt64.write(value.epoch, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHmacKey_lift(_ buf: RustBuffer) throws -> FfiHmacKey {
    return try FfiConverterTypeFfiHmacKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiHmacKey_lower(_ value: FfiHmacKey) -> RustBuffer {
    return FfiConverterTypeFfiHmacKey.lower(value)
}


public struct FfiIdentifier {
    public var identifier: String
    public var identifierKind: FfiIdentifierKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: String, identifierKind: FfiIdentifierKind) {
        self.identifier = identifier
        self.identifierKind = identifierKind
    }
}

#if compiler(>=6)
extension FfiIdentifier: Sendable {}
#endif


extension FfiIdentifier: Equatable, Hashable {
    public static func ==(lhs: FfiIdentifier, rhs: FfiIdentifier) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.identifierKind != rhs.identifierKind {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(identifierKind)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIdentifier {
        return
            try FfiIdentifier(
                identifier: FfiConverterString.read(from: &buf), 
                identifierKind: FfiConverterTypeFfiIdentifierKind.read(from: &buf)
        )
    }

    public static func write(_ value: FfiIdentifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterTypeFfiIdentifierKind.write(value.identifierKind, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifier_lift(_ buf: RustBuffer) throws -> FfiIdentifier {
    return try FfiConverterTypeFfiIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifier_lower(_ value: FfiIdentifier) -> RustBuffer {
    return FfiConverterTypeFfiIdentifier.lower(value)
}


public struct FfiIdentityStats {
    public var publishIdentityUpdate: UInt64
    public var getIdentityUpdatesV2: UInt64
    public var getInboxIds: UInt64
    public var verifySmartContractWalletSignature: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publishIdentityUpdate: UInt64, getIdentityUpdatesV2: UInt64, getInboxIds: UInt64, verifySmartContractWalletSignature: UInt64) {
        self.publishIdentityUpdate = publishIdentityUpdate
        self.getIdentityUpdatesV2 = getIdentityUpdatesV2
        self.getInboxIds = getInboxIds
        self.verifySmartContractWalletSignature = verifySmartContractWalletSignature
    }
}

#if compiler(>=6)
extension FfiIdentityStats: Sendable {}
#endif


extension FfiIdentityStats: Equatable, Hashable {
    public static func ==(lhs: FfiIdentityStats, rhs: FfiIdentityStats) -> Bool {
        if lhs.publishIdentityUpdate != rhs.publishIdentityUpdate {
            return false
        }
        if lhs.getIdentityUpdatesV2 != rhs.getIdentityUpdatesV2 {
            return false
        }
        if lhs.getInboxIds != rhs.getInboxIds {
            return false
        }
        if lhs.verifySmartContractWalletSignature != rhs.verifySmartContractWalletSignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publishIdentityUpdate)
        hasher.combine(getIdentityUpdatesV2)
        hasher.combine(getInboxIds)
        hasher.combine(verifySmartContractWalletSignature)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIdentityStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIdentityStats {
        return
            try FfiIdentityStats(
                publishIdentityUpdate: FfiConverterUInt64.read(from: &buf), 
                getIdentityUpdatesV2: FfiConverterUInt64.read(from: &buf), 
                getInboxIds: FfiConverterUInt64.read(from: &buf), 
                verifySmartContractWalletSignature: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiIdentityStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.publishIdentityUpdate, into: &buf)
        FfiConverterUInt64.write(value.getIdentityUpdatesV2, into: &buf)
        FfiConverterUInt64.write(value.getInboxIds, into: &buf)
        FfiConverterUInt64.write(value.verifySmartContractWalletSignature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentityStats_lift(_ buf: RustBuffer) throws -> FfiIdentityStats {
    return try FfiConverterTypeFfiIdentityStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentityStats_lower(_ value: FfiIdentityStats) -> RustBuffer {
    return FfiConverterTypeFfiIdentityStats.lower(value)
}


public struct FfiInboxState {
    public var inboxId: String
    public var recoveryIdentity: FfiIdentifier
    public var installations: [FfiInstallation]
    public var accountIdentities: [FfiIdentifier]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String, recoveryIdentity: FfiIdentifier, installations: [FfiInstallation], accountIdentities: [FfiIdentifier]) {
        self.inboxId = inboxId
        self.recoveryIdentity = recoveryIdentity
        self.installations = installations
        self.accountIdentities = accountIdentities
    }
}

#if compiler(>=6)
extension FfiInboxState: Sendable {}
#endif


extension FfiInboxState: Equatable, Hashable {
    public static func ==(lhs: FfiInboxState, rhs: FfiInboxState) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        if lhs.recoveryIdentity != rhs.recoveryIdentity {
            return false
        }
        if lhs.installations != rhs.installations {
            return false
        }
        if lhs.accountIdentities != rhs.accountIdentities {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
        hasher.combine(recoveryIdentity)
        hasher.combine(installations)
        hasher.combine(accountIdentities)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInboxState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInboxState {
        return
            try FfiInboxState(
                inboxId: FfiConverterString.read(from: &buf), 
                recoveryIdentity: FfiConverterTypeFfiIdentifier.read(from: &buf), 
                installations: FfiConverterSequenceTypeFfiInstallation.read(from: &buf), 
                accountIdentities: FfiConverterSequenceTypeFfiIdentifier.read(from: &buf)
        )
    }

    public static func write(_ value: FfiInboxState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
        FfiConverterTypeFfiIdentifier.write(value.recoveryIdentity, into: &buf)
        FfiConverterSequenceTypeFfiInstallation.write(value.installations, into: &buf)
        FfiConverterSequenceTypeFfiIdentifier.write(value.accountIdentities, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxState_lift(_ buf: RustBuffer) throws -> FfiInboxState {
    return try FfiConverterTypeFfiInboxState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInboxState_lower(_ value: FfiInboxState) -> RustBuffer {
    return FfiConverterTypeFfiInboxState.lower(value)
}


public struct FfiInstallation {
    public var id: Data
    public var clientTimestampNs: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, clientTimestampNs: UInt64?) {
        self.id = id
        self.clientTimestampNs = clientTimestampNs
    }
}

#if compiler(>=6)
extension FfiInstallation: Sendable {}
#endif


extension FfiInstallation: Equatable, Hashable {
    public static func ==(lhs: FfiInstallation, rhs: FfiInstallation) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.clientTimestampNs != rhs.clientTimestampNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(clientTimestampNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiInstallation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInstallation {
        return
            try FfiInstallation(
                id: FfiConverterData.read(from: &buf), 
                clientTimestampNs: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiInstallation, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterOptionUInt64.write(value.clientTimestampNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInstallation_lift(_ buf: RustBuffer) throws -> FfiInstallation {
    return try FfiConverterTypeFfiInstallation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiInstallation_lower(_ value: FfiInstallation) -> RustBuffer {
    return FfiConverterTypeFfiInstallation.lower(value)
}


public struct FfiKeyPackageStatus {
    public var lifetime: FfiLifetime?
    public var validationError: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lifetime: FfiLifetime?, validationError: String?) {
        self.lifetime = lifetime
        self.validationError = validationError
    }
}

#if compiler(>=6)
extension FfiKeyPackageStatus: Sendable {}
#endif


extension FfiKeyPackageStatus: Equatable, Hashable {
    public static func ==(lhs: FfiKeyPackageStatus, rhs: FfiKeyPackageStatus) -> Bool {
        if lhs.lifetime != rhs.lifetime {
            return false
        }
        if lhs.validationError != rhs.validationError {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lifetime)
        hasher.combine(validationError)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiKeyPackageStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiKeyPackageStatus {
        return
            try FfiKeyPackageStatus(
                lifetime: FfiConverterOptionTypeFfiLifetime.read(from: &buf), 
                validationError: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiKeyPackageStatus, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiLifetime.write(value.lifetime, into: &buf)
        FfiConverterOptionString.write(value.validationError, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyPackageStatus_lift(_ buf: RustBuffer) throws -> FfiKeyPackageStatus {
    return try FfiConverterTypeFfiKeyPackageStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyPackageStatus_lower(_ value: FfiKeyPackageStatus) -> RustBuffer {
    return FfiConverterTypeFfiKeyPackageStatus.lower(value)
}


public struct FfiLifetime {
    public var notBefore: UInt64
    public var notAfter: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(notBefore: UInt64, notAfter: UInt64) {
        self.notBefore = notBefore
        self.notAfter = notAfter
    }
}

#if compiler(>=6)
extension FfiLifetime: Sendable {}
#endif


extension FfiLifetime: Equatable, Hashable {
    public static func ==(lhs: FfiLifetime, rhs: FfiLifetime) -> Bool {
        if lhs.notBefore != rhs.notBefore {
            return false
        }
        if lhs.notAfter != rhs.notAfter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(notBefore)
        hasher.combine(notAfter)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLifetime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLifetime {
        return
            try FfiLifetime(
                notBefore: FfiConverterUInt64.read(from: &buf), 
                notAfter: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiLifetime, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.notBefore, into: &buf)
        FfiConverterUInt64.write(value.notAfter, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLifetime_lift(_ buf: RustBuffer) throws -> FfiLifetime {
    return try FfiConverterTypeFfiLifetime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLifetime_lower(_ value: FfiLifetime) -> RustBuffer {
    return FfiConverterTypeFfiLifetime.lower(value)
}


public struct FfiListConversationsOptions {
    public var createdAfterNs: Int64?
    public var createdBeforeNs: Int64?
    public var limit: Int64?
    public var consentStates: [FfiConsentState]?
    public var includeDuplicateDms: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAfterNs: Int64?, createdBeforeNs: Int64?, limit: Int64?, consentStates: [FfiConsentState]?, includeDuplicateDms: Bool) {
        self.createdAfterNs = createdAfterNs
        self.createdBeforeNs = createdBeforeNs
        self.limit = limit
        self.consentStates = consentStates
        self.includeDuplicateDms = includeDuplicateDms
    }
}

#if compiler(>=6)
extension FfiListConversationsOptions: Sendable {}
#endif


extension FfiListConversationsOptions: Equatable, Hashable {
    public static func ==(lhs: FfiListConversationsOptions, rhs: FfiListConversationsOptions) -> Bool {
        if lhs.createdAfterNs != rhs.createdAfterNs {
            return false
        }
        if lhs.createdBeforeNs != rhs.createdBeforeNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.consentStates != rhs.consentStates {
            return false
        }
        if lhs.includeDuplicateDms != rhs.includeDuplicateDms {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAfterNs)
        hasher.combine(createdBeforeNs)
        hasher.combine(limit)
        hasher.combine(consentStates)
        hasher.combine(includeDuplicateDms)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiListConversationsOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListConversationsOptions {
        return
            try FfiListConversationsOptions(
                createdAfterNs: FfiConverterOptionInt64.read(from: &buf), 
                createdBeforeNs: FfiConverterOptionInt64.read(from: &buf), 
                limit: FfiConverterOptionInt64.read(from: &buf), 
                consentStates: FfiConverterOptionSequenceTypeFfiConsentState.read(from: &buf), 
                includeDuplicateDms: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiListConversationsOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.createdAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.createdBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
        FfiConverterOptionSequenceTypeFfiConsentState.write(value.consentStates, into: &buf)
        FfiConverterBool.write(value.includeDuplicateDms, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListConversationsOptions_lift(_ buf: RustBuffer) throws -> FfiListConversationsOptions {
    return try FfiConverterTypeFfiListConversationsOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListConversationsOptions_lower(_ value: FfiListConversationsOptions) -> RustBuffer {
    return FfiConverterTypeFfiListConversationsOptions.lower(value)
}


public struct FfiListMessagesOptions {
    public var sentBeforeNs: Int64?
    public var sentAfterNs: Int64?
    public var limit: Int64?
    public var deliveryStatus: FfiDeliveryStatus?
    public var direction: FfiDirection?
    public var contentTypes: [FfiContentType]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sentBeforeNs: Int64?, sentAfterNs: Int64?, limit: Int64?, deliveryStatus: FfiDeliveryStatus?, direction: FfiDirection?, contentTypes: [FfiContentType]?) {
        self.sentBeforeNs = sentBeforeNs
        self.sentAfterNs = sentAfterNs
        self.limit = limit
        self.deliveryStatus = deliveryStatus
        self.direction = direction
        self.contentTypes = contentTypes
    }
}

#if compiler(>=6)
extension FfiListMessagesOptions: Sendable {}
#endif


extension FfiListMessagesOptions: Equatable, Hashable {
    public static func ==(lhs: FfiListMessagesOptions, rhs: FfiListMessagesOptions) -> Bool {
        if lhs.sentBeforeNs != rhs.sentBeforeNs {
            return false
        }
        if lhs.sentAfterNs != rhs.sentAfterNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.deliveryStatus != rhs.deliveryStatus {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.contentTypes != rhs.contentTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sentBeforeNs)
        hasher.combine(sentAfterNs)
        hasher.combine(limit)
        hasher.combine(deliveryStatus)
        hasher.combine(direction)
        hasher.combine(contentTypes)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiListMessagesOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListMessagesOptions {
        return
            try FfiListMessagesOptions(
                sentBeforeNs: FfiConverterOptionInt64.read(from: &buf), 
                sentAfterNs: FfiConverterOptionInt64.read(from: &buf), 
                limit: FfiConverterOptionInt64.read(from: &buf), 
                deliveryStatus: FfiConverterOptionTypeFfiDeliveryStatus.read(from: &buf), 
                direction: FfiConverterOptionTypeFfiDirection.read(from: &buf), 
                contentTypes: FfiConverterOptionSequenceTypeFfiContentType.read(from: &buf)
        )
    }

    public static func write(_ value: FfiListMessagesOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.sentBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.sentAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
        FfiConverterOptionTypeFfiDeliveryStatus.write(value.deliveryStatus, into: &buf)
        FfiConverterOptionTypeFfiDirection.write(value.direction, into: &buf)
        FfiConverterOptionSequenceTypeFfiContentType.write(value.contentTypes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListMessagesOptions_lift(_ buf: RustBuffer) throws -> FfiListMessagesOptions {
    return try FfiConverterTypeFfiListMessagesOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiListMessagesOptions_lower(_ value: FfiListMessagesOptions) -> RustBuffer {
    return FfiConverterTypeFfiListMessagesOptions.lower(value)
}


public struct FfiMessage {
    public var id: Data
    public var sentAtNs: Int64
    public var conversationId: Data
    public var senderInboxId: String
    public var content: Data
    public var kind: FfiConversationMessageKind
    public var deliveryStatus: FfiDeliveryStatus
    public var sequenceId: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, sentAtNs: Int64, conversationId: Data, senderInboxId: String, content: Data, kind: FfiConversationMessageKind, deliveryStatus: FfiDeliveryStatus, sequenceId: UInt64?) {
        self.id = id
        self.sentAtNs = sentAtNs
        self.conversationId = conversationId
        self.senderInboxId = senderInboxId
        self.content = content
        self.kind = kind
        self.deliveryStatus = deliveryStatus
        self.sequenceId = sequenceId
    }
}

#if compiler(>=6)
extension FfiMessage: Sendable {}
#endif


extension FfiMessage: Equatable, Hashable {
    public static func ==(lhs: FfiMessage, rhs: FfiMessage) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.sentAtNs != rhs.sentAtNs {
            return false
        }
        if lhs.conversationId != rhs.conversationId {
            return false
        }
        if lhs.senderInboxId != rhs.senderInboxId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.deliveryStatus != rhs.deliveryStatus {
            return false
        }
        if lhs.sequenceId != rhs.sequenceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(sentAtNs)
        hasher.combine(conversationId)
        hasher.combine(senderInboxId)
        hasher.combine(content)
        hasher.combine(kind)
        hasher.combine(deliveryStatus)
        hasher.combine(sequenceId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessage {
        return
            try FfiMessage(
                id: FfiConverterData.read(from: &buf), 
                sentAtNs: FfiConverterInt64.read(from: &buf), 
                conversationId: FfiConverterData.read(from: &buf), 
                senderInboxId: FfiConverterString.read(from: &buf), 
                content: FfiConverterData.read(from: &buf), 
                kind: FfiConverterTypeFfiConversationMessageKind.read(from: &buf), 
                deliveryStatus: FfiConverterTypeFfiDeliveryStatus.read(from: &buf), 
                sequenceId: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessage, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterInt64.write(value.sentAtNs, into: &buf)
        FfiConverterData.write(value.conversationId, into: &buf)
        FfiConverterString.write(value.senderInboxId, into: &buf)
        FfiConverterData.write(value.content, into: &buf)
        FfiConverterTypeFfiConversationMessageKind.write(value.kind, into: &buf)
        FfiConverterTypeFfiDeliveryStatus.write(value.deliveryStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.sequenceId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessage_lift(_ buf: RustBuffer) throws -> FfiMessage {
    return try FfiConverterTypeFfiMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessage_lower(_ value: FfiMessage) -> RustBuffer {
    return FfiConverterTypeFfiMessage.lower(value)
}


/**
 * Settings for disappearing messages in a conversation.
 *
 * # Fields
 *
 * * `from_ns` - The timestamp (in nanoseconds) from when messages should be tracked for deletion.
 * * `in_ns` - The duration (in nanoseconds) after which tracked messages will be deleted.
 */
public struct FfiMessageDisappearingSettings {
    public var fromNs: Int64
    public var inNs: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fromNs: Int64, inNs: Int64) {
        self.fromNs = fromNs
        self.inNs = inNs
    }
}

#if compiler(>=6)
extension FfiMessageDisappearingSettings: Sendable {}
#endif


extension FfiMessageDisappearingSettings: Equatable, Hashable {
    public static func ==(lhs: FfiMessageDisappearingSettings, rhs: FfiMessageDisappearingSettings) -> Bool {
        if lhs.fromNs != rhs.fromNs {
            return false
        }
        if lhs.inNs != rhs.inNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fromNs)
        hasher.combine(inNs)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageDisappearingSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageDisappearingSettings {
        return
            try FfiMessageDisappearingSettings(
                fromNs: FfiConverterInt64.read(from: &buf), 
                inNs: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessageDisappearingSettings, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.fromNs, into: &buf)
        FfiConverterInt64.write(value.inNs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageDisappearingSettings_lift(_ buf: RustBuffer) throws -> FfiMessageDisappearingSettings {
    return try FfiConverterTypeFfiMessageDisappearingSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageDisappearingSettings_lower(_ value: FfiMessageDisappearingSettings) -> RustBuffer {
    return FfiConverterTypeFfiMessageDisappearingSettings.lower(value)
}


public struct FfiMessageWithReactions {
    public var message: FfiMessage
    public var reactions: [FfiMessage]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: FfiMessage, reactions: [FfiMessage]) {
        self.message = message
        self.reactions = reactions
    }
}

#if compiler(>=6)
extension FfiMessageWithReactions: Sendable {}
#endif


extension FfiMessageWithReactions: Equatable, Hashable {
    public static func ==(lhs: FfiMessageWithReactions, rhs: FfiMessageWithReactions) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.reactions != rhs.reactions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(reactions)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMessageWithReactions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessageWithReactions {
        return
            try FfiMessageWithReactions(
                message: FfiConverterTypeFfiMessage.read(from: &buf), 
                reactions: FfiConverterSequenceTypeFfiMessage.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessageWithReactions, into buf: inout [UInt8]) {
        FfiConverterTypeFfiMessage.write(value.message, into: &buf)
        FfiConverterSequenceTypeFfiMessage.write(value.reactions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageWithReactions_lift(_ buf: RustBuffer) throws -> FfiMessageWithReactions {
    return try FfiConverterTypeFfiMessageWithReactions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMessageWithReactions_lower(_ value: FfiMessageWithReactions) -> RustBuffer {
    return FfiConverterTypeFfiMessageWithReactions.lower(value)
}


public struct FfiMultiRemoteAttachment {
    public var attachments: [FfiRemoteAttachmentInfo]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(attachments: [FfiRemoteAttachmentInfo]) {
        self.attachments = attachments
    }
}

#if compiler(>=6)
extension FfiMultiRemoteAttachment: Sendable {}
#endif


extension FfiMultiRemoteAttachment: Equatable, Hashable {
    public static func ==(lhs: FfiMultiRemoteAttachment, rhs: FfiMultiRemoteAttachment) -> Bool {
        if lhs.attachments != rhs.attachments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attachments)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMultiRemoteAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMultiRemoteAttachment {
        return
            try FfiMultiRemoteAttachment(
                attachments: FfiConverterSequenceTypeFfiRemoteAttachmentInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMultiRemoteAttachment, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiRemoteAttachmentInfo.write(value.attachments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMultiRemoteAttachment_lift(_ buf: RustBuffer) throws -> FfiMultiRemoteAttachment {
    return try FfiConverterTypeFfiMultiRemoteAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMultiRemoteAttachment_lower(_ value: FfiMultiRemoteAttachment) -> RustBuffer {
    return FfiConverterTypeFfiMultiRemoteAttachment.lower(value)
}


public struct FfiPasskeySignature {
    public var publicKey: Data
    public var signature: Data
    public var authenticatorData: Data
    public var clientDataJson: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: Data, signature: Data, authenticatorData: Data, clientDataJson: Data) {
        self.publicKey = publicKey
        self.signature = signature
        self.authenticatorData = authenticatorData
        self.clientDataJson = clientDataJson
    }
}

#if compiler(>=6)
extension FfiPasskeySignature: Sendable {}
#endif


extension FfiPasskeySignature: Equatable, Hashable {
    public static func ==(lhs: FfiPasskeySignature, rhs: FfiPasskeySignature) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.authenticatorData != rhs.authenticatorData {
            return false
        }
        if lhs.clientDataJson != rhs.clientDataJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(signature)
        hasher.combine(authenticatorData)
        hasher.combine(clientDataJson)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPasskeySignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPasskeySignature {
        return
            try FfiPasskeySignature(
                publicKey: FfiConverterData.read(from: &buf), 
                signature: FfiConverterData.read(from: &buf), 
                authenticatorData: FfiConverterData.read(from: &buf), 
                clientDataJson: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPasskeySignature, into buf: inout [UInt8]) {
        FfiConverterData.write(value.publicKey, into: &buf)
        FfiConverterData.write(value.signature, into: &buf)
        FfiConverterData.write(value.authenticatorData, into: &buf)
        FfiConverterData.write(value.clientDataJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPasskeySignature_lift(_ buf: RustBuffer) throws -> FfiPasskeySignature {
    return try FfiConverterTypeFfiPasskeySignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPasskeySignature_lower(_ value: FfiPasskeySignature) -> RustBuffer {
    return FfiConverterTypeFfiPasskeySignature.lower(value)
}


public struct FfiPermissionPolicySet {
    public var addMemberPolicy: FfiPermissionPolicy
    public var removeMemberPolicy: FfiPermissionPolicy
    public var addAdminPolicy: FfiPermissionPolicy
    public var removeAdminPolicy: FfiPermissionPolicy
    public var updateGroupNamePolicy: FfiPermissionPolicy
    public var updateGroupDescriptionPolicy: FfiPermissionPolicy
    public var updateGroupImageUrlSquarePolicy: FfiPermissionPolicy
    public var updateMessageDisappearingPolicy: FfiPermissionPolicy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addMemberPolicy: FfiPermissionPolicy, removeMemberPolicy: FfiPermissionPolicy, addAdminPolicy: FfiPermissionPolicy, removeAdminPolicy: FfiPermissionPolicy, updateGroupNamePolicy: FfiPermissionPolicy, updateGroupDescriptionPolicy: FfiPermissionPolicy, updateGroupImageUrlSquarePolicy: FfiPermissionPolicy, updateMessageDisappearingPolicy: FfiPermissionPolicy) {
        self.addMemberPolicy = addMemberPolicy
        self.removeMemberPolicy = removeMemberPolicy
        self.addAdminPolicy = addAdminPolicy
        self.removeAdminPolicy = removeAdminPolicy
        self.updateGroupNamePolicy = updateGroupNamePolicy
        self.updateGroupDescriptionPolicy = updateGroupDescriptionPolicy
        self.updateGroupImageUrlSquarePolicy = updateGroupImageUrlSquarePolicy
        self.updateMessageDisappearingPolicy = updateMessageDisappearingPolicy
    }
}

#if compiler(>=6)
extension FfiPermissionPolicySet: Sendable {}
#endif


extension FfiPermissionPolicySet: Equatable, Hashable {
    public static func ==(lhs: FfiPermissionPolicySet, rhs: FfiPermissionPolicySet) -> Bool {
        if lhs.addMemberPolicy != rhs.addMemberPolicy {
            return false
        }
        if lhs.removeMemberPolicy != rhs.removeMemberPolicy {
            return false
        }
        if lhs.addAdminPolicy != rhs.addAdminPolicy {
            return false
        }
        if lhs.removeAdminPolicy != rhs.removeAdminPolicy {
            return false
        }
        if lhs.updateGroupNamePolicy != rhs.updateGroupNamePolicy {
            return false
        }
        if lhs.updateGroupDescriptionPolicy != rhs.updateGroupDescriptionPolicy {
            return false
        }
        if lhs.updateGroupImageUrlSquarePolicy != rhs.updateGroupImageUrlSquarePolicy {
            return false
        }
        if lhs.updateMessageDisappearingPolicy != rhs.updateMessageDisappearingPolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addMemberPolicy)
        hasher.combine(removeMemberPolicy)
        hasher.combine(addAdminPolicy)
        hasher.combine(removeAdminPolicy)
        hasher.combine(updateGroupNamePolicy)
        hasher.combine(updateGroupDescriptionPolicy)
        hasher.combine(updateGroupImageUrlSquarePolicy)
        hasher.combine(updateMessageDisappearingPolicy)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionPolicySet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionPolicySet {
        return
            try FfiPermissionPolicySet(
                addMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                removeMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                addAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                removeAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateGroupNamePolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateGroupDescriptionPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateGroupImageUrlSquarePolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf), 
                updateMessageDisappearingPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPermissionPolicySet, into buf: inout [UInt8]) {
        FfiConverterTypeFfiPermissionPolicy.write(value.addMemberPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.removeMemberPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.addAdminPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.removeAdminPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupNamePolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupDescriptionPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupImageUrlSquarePolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateMessageDisappearingPolicy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicySet_lift(_ buf: RustBuffer) throws -> FfiPermissionPolicySet {
    return try FfiConverterTypeFfiPermissionPolicySet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicySet_lower(_ value: FfiPermissionPolicySet) -> RustBuffer {
    return FfiConverterTypeFfiPermissionPolicySet.lower(value)
}


public struct FfiReaction {
    public var reference: String
    public var referenceInboxId: String
    public var action: FfiReactionAction
    public var content: String
    public var schema: FfiReactionSchema

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(reference: String, referenceInboxId: String, action: FfiReactionAction, content: String, schema: FfiReactionSchema) {
        self.reference = reference
        self.referenceInboxId = referenceInboxId
        self.action = action
        self.content = content
        self.schema = schema
    }
}

#if compiler(>=6)
extension FfiReaction: Sendable {}
#endif


extension FfiReaction: Equatable, Hashable {
    public static func ==(lhs: FfiReaction, rhs: FfiReaction) -> Bool {
        if lhs.reference != rhs.reference {
            return false
        }
        if lhs.referenceInboxId != rhs.referenceInboxId {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.schema != rhs.schema {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reference)
        hasher.combine(referenceInboxId)
        hasher.combine(action)
        hasher.combine(content)
        hasher.combine(schema)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReaction {
        return
            try FfiReaction(
                reference: FfiConverterString.read(from: &buf), 
                referenceInboxId: FfiConverterString.read(from: &buf), 
                action: FfiConverterTypeFfiReactionAction.read(from: &buf), 
                content: FfiConverterString.read(from: &buf), 
                schema: FfiConverterTypeFfiReactionSchema.read(from: &buf)
        )
    }

    public static func write(_ value: FfiReaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.reference, into: &buf)
        FfiConverterString.write(value.referenceInboxId, into: &buf)
        FfiConverterTypeFfiReactionAction.write(value.action, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterTypeFfiReactionSchema.write(value.schema, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReaction_lift(_ buf: RustBuffer) throws -> FfiReaction {
    return try FfiConverterTypeFfiReaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReaction_lower(_ value: FfiReaction) -> RustBuffer {
    return FfiConverterTypeFfiReaction.lower(value)
}


public struct FfiRemoteAttachmentInfo {
    public var secret: Data
    public var contentDigest: String
    public var nonce: Data
    public var scheme: String
    public var url: String
    public var salt: Data
    public var contentLength: UInt32?
    public var filename: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(secret: Data, contentDigest: String, nonce: Data, scheme: String, url: String, salt: Data, contentLength: UInt32?, filename: String?) {
        self.secret = secret
        self.contentDigest = contentDigest
        self.nonce = nonce
        self.scheme = scheme
        self.url = url
        self.salt = salt
        self.contentLength = contentLength
        self.filename = filename
    }
}

#if compiler(>=6)
extension FfiRemoteAttachmentInfo: Sendable {}
#endif


extension FfiRemoteAttachmentInfo: Equatable, Hashable {
    public static func ==(lhs: FfiRemoteAttachmentInfo, rhs: FfiRemoteAttachmentInfo) -> Bool {
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.contentDigest != rhs.contentDigest {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.scheme != rhs.scheme {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.salt != rhs.salt {
            return false
        }
        if lhs.contentLength != rhs.contentLength {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secret)
        hasher.combine(contentDigest)
        hasher.combine(nonce)
        hasher.combine(scheme)
        hasher.combine(url)
        hasher.combine(salt)
        hasher.combine(contentLength)
        hasher.combine(filename)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiRemoteAttachmentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRemoteAttachmentInfo {
        return
            try FfiRemoteAttachmentInfo(
                secret: FfiConverterData.read(from: &buf), 
                contentDigest: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterData.read(from: &buf), 
                scheme: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                salt: FfiConverterData.read(from: &buf), 
                contentLength: FfiConverterOptionUInt32.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiRemoteAttachmentInfo, into buf: inout [UInt8]) {
        FfiConverterData.write(value.secret, into: &buf)
        FfiConverterString.write(value.contentDigest, into: &buf)
        FfiConverterData.write(value.nonce, into: &buf)
        FfiConverterString.write(value.scheme, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterData.write(value.salt, into: &buf)
        FfiConverterOptionUInt32.write(value.contentLength, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiRemoteAttachmentInfo_lift(_ buf: RustBuffer) throws -> FfiRemoteAttachmentInfo {
    return try FfiConverterTypeFfiRemoteAttachmentInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiRemoteAttachmentInfo_lower(_ value: FfiRemoteAttachmentInfo) -> RustBuffer {
    return FfiConverterTypeFfiRemoteAttachmentInfo.lower(value)
}


public struct FfiTransactionMetadata {
    public var transactionType: String
    public var currency: String
    public var amount: Double
    public var decimals: UInt32
    public var fromAddress: String
    public var toAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionType: String, currency: String, amount: Double, decimals: UInt32, fromAddress: String, toAddress: String) {
        self.transactionType = transactionType
        self.currency = currency
        self.amount = amount
        self.decimals = decimals
        self.fromAddress = fromAddress
        self.toAddress = toAddress
    }
}

#if compiler(>=6)
extension FfiTransactionMetadata: Sendable {}
#endif


extension FfiTransactionMetadata: Equatable, Hashable {
    public static func ==(lhs: FfiTransactionMetadata, rhs: FfiTransactionMetadata) -> Bool {
        if lhs.transactionType != rhs.transactionType {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.fromAddress != rhs.fromAddress {
            return false
        }
        if lhs.toAddress != rhs.toAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionType)
        hasher.combine(currency)
        hasher.combine(amount)
        hasher.combine(decimals)
        hasher.combine(fromAddress)
        hasher.combine(toAddress)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTransactionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTransactionMetadata {
        return
            try FfiTransactionMetadata(
                transactionType: FfiConverterString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                amount: FfiConverterDouble.read(from: &buf), 
                decimals: FfiConverterUInt32.read(from: &buf), 
                fromAddress: FfiConverterString.read(from: &buf), 
                toAddress: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTransactionMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.transactionType, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterDouble.write(value.amount, into: &buf)
        FfiConverterUInt32.write(value.decimals, into: &buf)
        FfiConverterString.write(value.fromAddress, into: &buf)
        FfiConverterString.write(value.toAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionMetadata_lift(_ buf: RustBuffer) throws -> FfiTransactionMetadata {
    return try FfiConverterTypeFfiTransactionMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionMetadata_lower(_ value: FfiTransactionMetadata) -> RustBuffer {
    return FfiConverterTypeFfiTransactionMetadata.lower(value)
}


public struct FfiTransactionReference {
    public var namespace: String?
    public var networkId: String
    public var reference: String
    public var metadata: FfiTransactionMetadata?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(namespace: String?, networkId: String, reference: String, metadata: FfiTransactionMetadata?) {
        self.namespace = namespace
        self.networkId = networkId
        self.reference = reference
        self.metadata = metadata
    }
}

#if compiler(>=6)
extension FfiTransactionReference: Sendable {}
#endif


extension FfiTransactionReference: Equatable, Hashable {
    public static func ==(lhs: FfiTransactionReference, rhs: FfiTransactionReference) -> Bool {
        if lhs.namespace != rhs.namespace {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.reference != rhs.reference {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(namespace)
        hasher.combine(networkId)
        hasher.combine(reference)
        hasher.combine(metadata)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTransactionReference: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTransactionReference {
        return
            try FfiTransactionReference(
                namespace: FfiConverterOptionString.read(from: &buf), 
                networkId: FfiConverterString.read(from: &buf), 
                reference: FfiConverterString.read(from: &buf), 
                metadata: FfiConverterOptionTypeFfiTransactionMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTransactionReference, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.namespace, into: &buf)
        FfiConverterString.write(value.networkId, into: &buf)
        FfiConverterString.write(value.reference, into: &buf)
        FfiConverterOptionTypeFfiTransactionMetadata.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionReference_lift(_ buf: RustBuffer) throws -> FfiTransactionReference {
    return try FfiConverterTypeFfiTransactionReference.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransactionReference_lower(_ value: FfiTransactionReference) -> RustBuffer {
    return FfiConverterTypeFfiTransactionReference.lower(value)
}


public struct FfiUpdateGroupMembershipResult {
    public var addedMembers: [String: UInt64]
    public var removedMembers: [String]
    public var failedInstallations: [Data]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addedMembers: [String: UInt64], removedMembers: [String], failedInstallations: [Data]) {
        self.addedMembers = addedMembers
        self.removedMembers = removedMembers
        self.failedInstallations = failedInstallations
    }
}

#if compiler(>=6)
extension FfiUpdateGroupMembershipResult: Sendable {}
#endif


extension FfiUpdateGroupMembershipResult: Equatable, Hashable {
    public static func ==(lhs: FfiUpdateGroupMembershipResult, rhs: FfiUpdateGroupMembershipResult) -> Bool {
        if lhs.addedMembers != rhs.addedMembers {
            return false
        }
        if lhs.removedMembers != rhs.removedMembers {
            return false
        }
        if lhs.failedInstallations != rhs.failedInstallations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addedMembers)
        hasher.combine(removedMembers)
        hasher.combine(failedInstallations)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiUpdateGroupMembershipResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUpdateGroupMembershipResult {
        return
            try FfiUpdateGroupMembershipResult(
                addedMembers: FfiConverterDictionaryStringUInt64.read(from: &buf), 
                removedMembers: FfiConverterSequenceString.read(from: &buf), 
                failedInstallations: FfiConverterSequenceData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiUpdateGroupMembershipResult, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringUInt64.write(value.addedMembers, into: &buf)
        FfiConverterSequenceString.write(value.removedMembers, into: &buf)
        FfiConverterSequenceData.write(value.failedInstallations, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiUpdateGroupMembershipResult_lift(_ buf: RustBuffer) throws -> FfiUpdateGroupMembershipResult {
    return try FfiConverterTypeFfiUpdateGroupMembershipResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiUpdateGroupMembershipResult_lower(_ value: FfiUpdateGroupMembershipResult) -> RustBuffer {
    return FfiConverterTypeFfiUpdateGroupMembershipResult.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiBackupElementSelection {
    
    case messages
    case consent
}


#if compiler(>=6)
extension FfiBackupElementSelection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiBackupElementSelection: FfiConverterRustBuffer {
    typealias SwiftType = FfiBackupElementSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiBackupElementSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messages
        
        case 2: return .consent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiBackupElementSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .messages:
            writeInt(&buf, Int32(1))
        
        
        case .consent:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupElementSelection_lift(_ buf: RustBuffer) throws -> FfiBackupElementSelection {
    return try FfiConverterTypeFfiBackupElementSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiBackupElementSelection_lower(_ value: FfiBackupElementSelection) -> RustBuffer {
    return FfiConverterTypeFfiBackupElementSelection.lower(value)
}


extension FfiBackupElementSelection: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConsentEntityType {
    
    case conversationId
    case inboxId
}


#if compiler(>=6)
extension FfiConsentEntityType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsentEntityType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConsentEntityType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentEntityType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .conversationId
        
        case 2: return .inboxId
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConsentEntityType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .conversationId:
            writeInt(&buf, Int32(1))
        
        
        case .inboxId:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentEntityType_lift(_ buf: RustBuffer) throws -> FfiConsentEntityType {
    return try FfiConverterTypeFfiConsentEntityType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentEntityType_lower(_ value: FfiConsentEntityType) -> RustBuffer {
    return FfiConverterTypeFfiConsentEntityType.lower(value)
}


extension FfiConsentEntityType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConsentState {
    
    case unknown
    case allowed
    case denied
}


#if compiler(>=6)
extension FfiConsentState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = FfiConsentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .allowed
        
        case 3: return .denied
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConsentState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .allowed:
            writeInt(&buf, Int32(2))
        
        
        case .denied:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentState_lift(_ buf: RustBuffer) throws -> FfiConsentState {
    return try FfiConverterTypeFfiConsentState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConsentState_lower(_ value: FfiConsentState) -> RustBuffer {
    return FfiConverterTypeFfiConsentState.lower(value)
}


extension FfiConsentState: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiContentType {
    
    case unknown
    case text
    case groupMembershipChange
    case groupUpdated
    case reaction
    case readReceipt
    case reply
    case attachment
    case remoteAttachment
    case transactionReference
}


#if compiler(>=6)
extension FfiContentType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiContentType: FfiConverterRustBuffer {
    typealias SwiftType = FfiContentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiContentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .text
        
        case 3: return .groupMembershipChange
        
        case 4: return .groupUpdated
        
        case 5: return .reaction
        
        case 6: return .readReceipt
        
        case 7: return .reply
        
        case 8: return .attachment
        
        case 9: return .remoteAttachment
        
        case 10: return .transactionReference
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiContentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .text:
            writeInt(&buf, Int32(2))
        
        
        case .groupMembershipChange:
            writeInt(&buf, Int32(3))
        
        
        case .groupUpdated:
            writeInt(&buf, Int32(4))
        
        
        case .reaction:
            writeInt(&buf, Int32(5))
        
        
        case .readReceipt:
            writeInt(&buf, Int32(6))
        
        
        case .reply:
            writeInt(&buf, Int32(7))
        
        
        case .attachment:
            writeInt(&buf, Int32(8))
        
        
        case .remoteAttachment:
            writeInt(&buf, Int32(9))
        
        
        case .transactionReference:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiContentType_lift(_ buf: RustBuffer) throws -> FfiContentType {
    return try FfiConverterTypeFfiContentType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiContentType_lower(_ value: FfiContentType) -> RustBuffer {
    return FfiConverterTypeFfiContentType.lower(value)
}


extension FfiContentType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConversationMessageKind {
    
    case application
    case membershipChange
}


#if compiler(>=6)
extension FfiConversationMessageKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationMessageKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiConversationMessageKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationMessageKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .application
        
        case 2: return .membershipChange
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConversationMessageKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .application:
            writeInt(&buf, Int32(1))
        
        
        case .membershipChange:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMessageKind_lift(_ buf: RustBuffer) throws -> FfiConversationMessageKind {
    return try FfiConverterTypeFfiConversationMessageKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationMessageKind_lower(_ value: FfiConversationMessageKind) -> RustBuffer {
    return FfiConverterTypeFfiConversationMessageKind.lower(value)
}


extension FfiConversationMessageKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConversationType {
    
    case group
    case dm
    case sync
}


#if compiler(>=6)
extension FfiConversationType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiConversationType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConversationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .group
        
        case 2: return .dm
        
        case 3: return .sync
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConversationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .group:
            writeInt(&buf, Int32(1))
        
        
        case .dm:
            writeInt(&buf, Int32(2))
        
        
        case .sync:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationType_lift(_ buf: RustBuffer) throws -> FfiConversationType {
    return try FfiConverterTypeFfiConversationType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiConversationType_lower(_ value: FfiConversationType) -> RustBuffer {
    return FfiConverterTypeFfiConversationType.lower(value)
}


extension FfiConversationType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDeliveryStatus {
    
    case unpublished
    case published
    case failed
}


#if compiler(>=6)
extension FfiDeliveryStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeliveryStatus: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeliveryStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeliveryStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unpublished
        
        case 2: return .published
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDeliveryStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unpublished:
            writeInt(&buf, Int32(1))
        
        
        case .published:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeliveryStatus_lift(_ buf: RustBuffer) throws -> FfiDeliveryStatus {
    return try FfiConverterTypeFfiDeliveryStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeliveryStatus_lower(_ value: FfiDeliveryStatus) -> RustBuffer {
    return FfiConverterTypeFfiDeliveryStatus.lower(value)
}


extension FfiDeliveryStatus: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDirection {
    
    case ascending
    case descending
}


#if compiler(>=6)
extension FfiDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDirection: FfiConverterRustBuffer {
    typealias SwiftType = FfiDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ascending
        
        case 2: return .descending
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ascending:
            writeInt(&buf, Int32(1))
        
        
        case .descending:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDirection_lift(_ buf: RustBuffer) throws -> FfiDirection {
    return try FfiConverterTypeFfiDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDirection_lower(_ value: FfiDirection) -> RustBuffer {
    return FfiConverterTypeFfiDirection.lower(value)
}


extension FfiDirection: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupPermissionsOptions {
    
    case `default`
    case adminOnly
    case customPolicy
}


#if compiler(>=6)
extension FfiGroupPermissionsOptions: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupPermissionsOptions: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupPermissionsOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupPermissionsOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`default`
        
        case 2: return .adminOnly
        
        case 3: return .customPolicy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupPermissionsOptions, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`default`:
            writeInt(&buf, Int32(1))
        
        
        case .adminOnly:
            writeInt(&buf, Int32(2))
        
        
        case .customPolicy:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissionsOptions_lift(_ buf: RustBuffer) throws -> FfiGroupPermissionsOptions {
    return try FfiConverterTypeFfiGroupPermissionsOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupPermissionsOptions_lower(_ value: FfiGroupPermissionsOptions) -> RustBuffer {
    return FfiConverterTypeFfiGroupPermissionsOptions.lower(value)
}


extension FfiGroupPermissionsOptions: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiIdentifierKind {
    
    case ethereum
    case passkey
}


#if compiler(>=6)
extension FfiIdentifierKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiIdentifierKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiIdentifierKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiIdentifierKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ethereum
        
        case 2: return .passkey
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiIdentifierKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ethereum:
            writeInt(&buf, Int32(1))
        
        
        case .passkey:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifierKind_lift(_ buf: RustBuffer) throws -> FfiIdentifierKind {
    return try FfiConverterTypeFfiIdentifierKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiIdentifierKind_lower(_ value: FfiIdentifierKind) -> RustBuffer {
    return FfiConverterTypeFfiIdentifierKind.lower(value)
}


extension FfiIdentifierKind: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing log levels
 */

public enum FfiLogLevel {
    
    /**
     * Error level logs only
     */
    case error
    /**
     * Warning level and above
     */
    case warn
    /**
     * Info level and above
     */
    case info
    /**
     * Debug level and above
     */
    case debug
    /**
     * Trace level and all logs
     */
    case trace
}


#if compiler(>=6)
extension FfiLogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = FfiLogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiLogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogLevel_lift(_ buf: RustBuffer) throws -> FfiLogLevel {
    return try FfiConverterTypeFfiLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogLevel_lower(_ value: FfiLogLevel) -> RustBuffer {
    return FfiConverterTypeFfiLogLevel.lower(value)
}


extension FfiLogLevel: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing log file rotation options
 */

public enum FfiLogRotation {
    
    /**
     * Rotate log files every minute
     */
    case minutely
    /**
     * Rotate log files every hour
     */
    case hourly
    /**
     * Rotate log files every day
     */
    case daily
    /**
     * Never rotate log files
     */
    case never
}


#if compiler(>=6)
extension FfiLogRotation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiLogRotation: FfiConverterRustBuffer {
    typealias SwiftType = FfiLogRotation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiLogRotation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .minutely
        
        case 2: return .hourly
        
        case 3: return .daily
        
        case 4: return .never
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiLogRotation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .minutely:
            writeInt(&buf, Int32(1))
        
        
        case .hourly:
            writeInt(&buf, Int32(2))
        
        
        case .daily:
            writeInt(&buf, Int32(3))
        
        
        case .never:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogRotation_lift(_ buf: RustBuffer) throws -> FfiLogRotation {
    return try FfiConverterTypeFfiLogRotation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiLogRotation_lower(_ value: FfiLogRotation) -> RustBuffer {
    return FfiConverterTypeFfiLogRotation.lower(value)
}


extension FfiLogRotation: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiMetadataField {
    
    case groupName
    case description
    case imageUrlSquare
}


#if compiler(>=6)
extension FfiMetadataField: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiMetadataField: FfiConverterRustBuffer {
    typealias SwiftType = FfiMetadataField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMetadataField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .groupName
        
        case 2: return .description
        
        case 3: return .imageUrlSquare
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiMetadataField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .groupName:
            writeInt(&buf, Int32(1))
        
        
        case .description:
            writeInt(&buf, Int32(2))
        
        
        case .imageUrlSquare:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMetadataField_lift(_ buf: RustBuffer) throws -> FfiMetadataField {
    return try FfiConverterTypeFfiMetadataField.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiMetadataField_lower(_ value: FfiMetadataField) -> RustBuffer {
    return FfiConverterTypeFfiMetadataField.lower(value)
}


extension FfiMetadataField: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionLevel {
    
    case member
    case admin
    case superAdmin
}


#if compiler(>=6)
extension FfiPermissionLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionLevel: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .member
        
        case 2: return .admin
        
        case 3: return .superAdmin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .member:
            writeInt(&buf, Int32(1))
        
        
        case .admin:
            writeInt(&buf, Int32(2))
        
        
        case .superAdmin:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionLevel_lift(_ buf: RustBuffer) throws -> FfiPermissionLevel {
    return try FfiConverterTypeFfiPermissionLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionLevel_lower(_ value: FfiPermissionLevel) -> RustBuffer {
    return FfiConverterTypeFfiPermissionLevel.lower(value)
}


extension FfiPermissionLevel: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionPolicy {
    
    case allow
    case deny
    case admin
    case superAdmin
    case doesNotExist
    case other
}


#if compiler(>=6)
extension FfiPermissionPolicy: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionPolicy: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allow
        
        case 2: return .deny
        
        case 3: return .admin
        
        case 4: return .superAdmin
        
        case 5: return .doesNotExist
        
        case 6: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionPolicy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allow:
            writeInt(&buf, Int32(1))
        
        
        case .deny:
            writeInt(&buf, Int32(2))
        
        
        case .admin:
            writeInt(&buf, Int32(3))
        
        
        case .superAdmin:
            writeInt(&buf, Int32(4))
        
        
        case .doesNotExist:
            writeInt(&buf, Int32(5))
        
        
        case .other:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicy_lift(_ buf: RustBuffer) throws -> FfiPermissionPolicy {
    return try FfiConverterTypeFfiPermissionPolicy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionPolicy_lower(_ value: FfiPermissionPolicy) -> RustBuffer {
    return FfiConverterTypeFfiPermissionPolicy.lower(value)
}


extension FfiPermissionPolicy: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionUpdateType {
    
    case addMember
    case removeMember
    case addAdmin
    case removeAdmin
    case updateMetadata
}


#if compiler(>=6)
extension FfiPermissionUpdateType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPermissionUpdateType: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionUpdateType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionUpdateType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .addMember
        
        case 2: return .removeMember
        
        case 3: return .addAdmin
        
        case 4: return .removeAdmin
        
        case 5: return .updateMetadata
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionUpdateType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .addMember:
            writeInt(&buf, Int32(1))
        
        
        case .removeMember:
            writeInt(&buf, Int32(2))
        
        
        case .addAdmin:
            writeInt(&buf, Int32(3))
        
        
        case .removeAdmin:
            writeInt(&buf, Int32(4))
        
        
        case .updateMetadata:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionUpdateType_lift(_ buf: RustBuffer) throws -> FfiPermissionUpdateType {
    return try FfiConverterTypeFfiPermissionUpdateType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPermissionUpdateType_lower(_ value: FfiPermissionUpdateType) -> RustBuffer {
    return FfiConverterTypeFfiPermissionUpdateType.lower(value)
}


extension FfiPermissionUpdateType: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPreferenceUpdate {
    
    case hmac(key: Data
    )
}


#if compiler(>=6)
extension FfiPreferenceUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiPreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = FfiPreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hmac(key: try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hmac(key):
            writeInt(&buf, Int32(1))
            FfiConverterData.write(key, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceUpdate_lift(_ buf: RustBuffer) throws -> FfiPreferenceUpdate {
    return try FfiConverterTypeFfiPreferenceUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiPreferenceUpdate_lower(_ value: FfiPreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeFfiPreferenceUpdate.lower(value)
}


extension FfiPreferenceUpdate: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiReactionAction {
    
    case unknown
    case added
    case removed
}


#if compiler(>=6)
extension FfiReactionAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReactionAction: FfiConverterRustBuffer {
    typealias SwiftType = FfiReactionAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReactionAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .added
        
        case 3: return .removed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiReactionAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .added:
            writeInt(&buf, Int32(2))
        
        
        case .removed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionAction_lift(_ buf: RustBuffer) throws -> FfiReactionAction {
    return try FfiConverterTypeFfiReactionAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionAction_lower(_ value: FfiReactionAction) -> RustBuffer {
    return FfiConverterTypeFfiReactionAction.lower(value)
}


extension FfiReactionAction: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiReactionSchema {
    
    case unknown
    case unicode
    case shortcode
    case custom
}


#if compiler(>=6)
extension FfiReactionSchema: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReactionSchema: FfiConverterRustBuffer {
    typealias SwiftType = FfiReactionSchema

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReactionSchema {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .unicode
        
        case 3: return .shortcode
        
        case 4: return .custom
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiReactionSchema, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .unicode:
            writeInt(&buf, Int32(2))
        
        
        case .shortcode:
            writeInt(&buf, Int32(3))
        
        
        case .custom:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionSchema_lift(_ buf: RustBuffer) throws -> FfiReactionSchema {
    return try FfiConverterTypeFfiReactionSchema.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReactionSchema_lower(_ value: FfiReactionSchema) -> RustBuffer {
    return FfiConverterTypeFfiReactionSchema.lower(value)
}


extension FfiReactionSchema: Equatable, Hashable {}







public enum FfiSubscribeError: Swift.Error {

    
    
    case Subscribe(message: String)
    
    case Storage(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSubscribeError: FfiConverterRustBuffer {
    typealias SwiftType = FfiSubscribeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSubscribeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Subscribe(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Storage(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSubscribeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Subscribe(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Storage(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSubscribeError_lift(_ buf: RustBuffer) throws -> FfiSubscribeError {
    return try FfiConverterTypeFfiSubscribeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSubscribeError_lower(_ value: FfiSubscribeError) -> RustBuffer {
    return FfiConverterTypeFfiSubscribeError.lower(value)
}


extension FfiSubscribeError: Equatable, Hashable {}




extension FfiSubscribeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiSyncMetric {
    
    case `init`
    case syncGroupCreated
    case syncGroupWelcomesProcessed
    case requestReceived
    case payloadSent
    case payloadProcessed
    case hmacSent
    case hmacReceived
    case consentSent
    case consentReceived
    case v1ConsentSent
    case v1HmacSent
    case v1PayloadSent
    case v1PayloadProcessed
}


#if compiler(>=6)
extension FfiSyncMetric: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSyncMetric: FfiConverterRustBuffer {
    typealias SwiftType = FfiSyncMetric

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSyncMetric {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`init`
        
        case 2: return .syncGroupCreated
        
        case 3: return .syncGroupWelcomesProcessed
        
        case 4: return .requestReceived
        
        case 5: return .payloadSent
        
        case 6: return .payloadProcessed
        
        case 7: return .hmacSent
        
        case 8: return .hmacReceived
        
        case 9: return .consentSent
        
        case 10: return .consentReceived
        
        case 11: return .v1ConsentSent
        
        case 12: return .v1HmacSent
        
        case 13: return .v1PayloadSent
        
        case 14: return .v1PayloadProcessed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSyncMetric, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`init`:
            writeInt(&buf, Int32(1))
        
        
        case .syncGroupCreated:
            writeInt(&buf, Int32(2))
        
        
        case .syncGroupWelcomesProcessed:
            writeInt(&buf, Int32(3))
        
        
        case .requestReceived:
            writeInt(&buf, Int32(4))
        
        
        case .payloadSent:
            writeInt(&buf, Int32(5))
        
        
        case .payloadProcessed:
            writeInt(&buf, Int32(6))
        
        
        case .hmacSent:
            writeInt(&buf, Int32(7))
        
        
        case .hmacReceived:
            writeInt(&buf, Int32(8))
        
        
        case .consentSent:
            writeInt(&buf, Int32(9))
        
        
        case .consentReceived:
            writeInt(&buf, Int32(10))
        
        
        case .v1ConsentSent:
            writeInt(&buf, Int32(11))
        
        
        case .v1HmacSent:
            writeInt(&buf, Int32(12))
        
        
        case .v1PayloadSent:
            writeInt(&buf, Int32(13))
        
        
        case .v1PayloadProcessed:
            writeInt(&buf, Int32(14))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncMetric_lift(_ buf: RustBuffer) throws -> FfiSyncMetric {
    return try FfiConverterTypeFfiSyncMetric.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncMetric_lower(_ value: FfiSyncMetric) -> RustBuffer {
    return FfiConverterTypeFfiSyncMetric.lower(value)
}


extension FfiSyncMetric: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiSyncWorkerMode {
    
    case enabled
    case disabled
}


#if compiler(>=6)
extension FfiSyncWorkerMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSyncWorkerMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiSyncWorkerMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSyncWorkerMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .enabled
        
        case 2: return .disabled
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSyncWorkerMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .enabled:
            writeInt(&buf, Int32(1))
        
        
        case .disabled:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncWorkerMode_lift(_ buf: RustBuffer) throws -> FfiSyncWorkerMode {
    return try FfiConverterTypeFfiSyncWorkerMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSyncWorkerMode_lower(_ value: FfiSyncWorkerMode) -> RustBuffer {
    return FfiConverterTypeFfiSyncWorkerMode.lower(value)
}


extension FfiSyncWorkerMode: Equatable, Hashable {}







public enum GenericError: Swift.Error {

    
    
    case Client(message: String)
    
    case ClientBuilder(message: String)
    
    case Storage(message: String)
    
    case GroupError(message: String)
    
    case Signature(message: String)
    
    case GroupMetadata(message: String)
    
    case GroupMutablePermissions(message: String)
    
    case Generic(message: String)
    
    case SignatureRequestError(message: String)
    
    case Erc1271SignatureError(message: String)
    
    case Verifier(message: String)
    
    case FailedToConvertToU32(message: String)
    
    case Association(message: String)
    
    case DeviceSync(message: String)
    
    case Identity(message: String)
    
    case JoinError(message: String)
    
    case IoError(message: String)
    
    case Subscription(message: String)
    
    case ApiClientBuild(message: String)
    
    case Grpc(message: String)
    
    case AddressValidation(message: String)
    
    case LogInit(message: String)
    
    case ReloadLog(message: String)
    
    case Log(message: String)
    
    case Expired(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGenericError: FfiConverterRustBuffer {
    typealias SwiftType = GenericError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Client(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ClientBuilder(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Storage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .GroupError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Signature(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .GroupMetadata(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .GroupMutablePermissions(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .SignatureRequestError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .Erc1271SignatureError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .Verifier(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .FailedToConvertToU32(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .Association(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .DeviceSync(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .Identity(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .JoinError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .IoError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .Subscription(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .ApiClientBuild(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .Grpc(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .AddressValidation(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .LogInit(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .ReloadLog(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 24: return .Log(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .Expired(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GenericError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Client(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .ClientBuilder(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Storage(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .GroupError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .Signature(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .GroupMetadata(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .GroupMutablePermissions(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .SignatureRequestError(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .Erc1271SignatureError(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .Verifier(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .FailedToConvertToU32(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .Association(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .DeviceSync(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .Identity(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .JoinError(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .IoError(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .Subscription(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))
        case .ApiClientBuild(_ /* message is ignored*/):
            writeInt(&buf, Int32(19))
        case .Grpc(_ /* message is ignored*/):
            writeInt(&buf, Int32(20))
        case .AddressValidation(_ /* message is ignored*/):
            writeInt(&buf, Int32(21))
        case .LogInit(_ /* message is ignored*/):
            writeInt(&buf, Int32(22))
        case .ReloadLog(_ /* message is ignored*/):
            writeInt(&buf, Int32(23))
        case .Log(_ /* message is ignored*/):
            writeInt(&buf, Int32(24))
        case .Expired(_ /* message is ignored*/):
            writeInt(&buf, Int32(25))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericError_lift(_ buf: RustBuffer) throws -> GenericError {
    return try FfiConverterTypeGenericError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericError_lower(_ value: GenericError) -> RustBuffer {
    return FfiConverterTypeGenericError.lower(value)
}


extension GenericError: Equatable, Hashable {}




extension GenericError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum IdentityValidationError: Swift.Error {

    
    
    case Generic(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityValidationError: FfiConverterRustBuffer {
    typealias SwiftType = IdentityValidationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityValidationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IdentityValidationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityValidationError_lift(_ buf: RustBuffer) throws -> IdentityValidationError {
    return try FfiConverterTypeIdentityValidationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityValidationError_lower(_ value: IdentityValidationError) -> RustBuffer {
    return FfiConverterTypeIdentityValidationError.lower(value)
}


extension IdentityValidationError: Equatable, Hashable {}




extension IdentityValidationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





public enum SigningError: Swift.Error {

    
    
    case Generic
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSigningError: FfiConverterRustBuffer {
    typealias SwiftType = SigningError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SigningError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SigningError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Generic:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningError_lift(_ buf: RustBuffer) throws -> SigningError {
    return try FfiConverterTypeSigningError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningError_lower(_ value: SigningError) -> RustBuffer {
    return FfiConverterTypeSigningError.lower(value)
}


extension SigningError: Equatable, Hashable {}




extension SigningError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiSignatureRequest: FfiConverterRustBuffer {
    typealias SwiftType = FfiSignatureRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiSignatureRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiSignatureRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiLifetime: FfiConverterRustBuffer {
    typealias SwiftType = FfiLifetime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiLifetime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiLifetime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiMessage: FfiConverterRustBuffer {
    typealias SwiftType = FfiMessage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiMessageDisappearingSettings: FfiConverterRustBuffer {
    typealias SwiftType = FfiMessageDisappearingSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMessageDisappearingSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMessageDisappearingSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiPermissionPolicySet: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionPolicySet?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiPermissionPolicySet.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiPermissionPolicySet.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiTransactionMetadata: FfiConverterRustBuffer {
    typealias SwiftType = FfiTransactionMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiTransactionMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiTransactionMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiConversationType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConversationType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiConversationType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiConversationType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDeliveryStatus: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeliveryStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDeliveryStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDeliveryStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiDirection: FfiConverterRustBuffer {
    typealias SwiftType = FfiDirection?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDirection.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDirection.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiGroupPermissionsOptions: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupPermissionsOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiGroupPermissionsOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiGroupPermissionsOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiMetadataField: FfiConverterRustBuffer {
    typealias SwiftType = FfiMetadataField?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMetadataField.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMetadataField.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiSyncWorkerMode: FfiConverterRustBuffer {
    typealias SwiftType = FfiSyncWorkerMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiSyncWorkerMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiSyncWorkerMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConsentState]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFfiConsentState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFfiConsentState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeFfiContentType: FfiConverterRustBuffer {
    typealias SwiftType = [FfiContentType]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFfiContentType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFfiContentType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConversation: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConversation]

    public static func write(_ value: [FfiConversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConversation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConversation] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConversation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConversation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConversationListItem: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConversationListItem]

    public static func write(_ value: [FfiConversationListItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConversationListItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConversationListItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConversationListItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConversationListItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConsent: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConsent]

    public static func write(_ value: [FfiConsent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConsent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConsent] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConsent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConsent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConversationMember: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConversationMember]

    public static func write(_ value: [FfiConversationMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConversationMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConversationMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConversationMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConversationMember.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiHmacKey: FfiConverterRustBuffer {
    typealias SwiftType = [FfiHmacKey]

    public static func write(_ value: [FfiHmacKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiHmacKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiHmacKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiHmacKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiHmacKey.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [FfiIdentifier]

    public static func write(_ value: [FfiIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiIdentifier.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiInboxState: FfiConverterRustBuffer {
    typealias SwiftType = [FfiInboxState]

    public static func write(_ value: [FfiInboxState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiInboxState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiInboxState] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiInboxState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiInboxState.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiInstallation: FfiConverterRustBuffer {
    typealias SwiftType = [FfiInstallation]

    public static func write(_ value: [FfiInstallation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiInstallation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiInstallation] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiInstallation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiInstallation.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiMessage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMessage]

    public static func write(_ value: [FfiMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiMessageWithReactions: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMessageWithReactions]

    public static func write(_ value: [FfiMessageWithReactions], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMessageWithReactions.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMessageWithReactions] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMessageWithReactions]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiMessageWithReactions.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiRemoteAttachmentInfo: FfiConverterRustBuffer {
    typealias SwiftType = [FfiRemoteAttachmentInfo]

    public static func write(_ value: [FfiRemoteAttachmentInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiRemoteAttachmentInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiRemoteAttachmentInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiRemoteAttachmentInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiRemoteAttachmentInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiBackupElementSelection: FfiConverterRustBuffer {
    typealias SwiftType = [FfiBackupElementSelection]

    public static func write(_ value: [FfiBackupElementSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiBackupElementSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiBackupElementSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiBackupElementSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiBackupElementSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = [FfiConsentState]

    public static func write(_ value: [FfiConsentState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiConsentState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiConsentState] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiConsentState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiConsentState.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiContentType: FfiConverterRustBuffer {
    typealias SwiftType = [FfiContentType]

    public static func write(_ value: [FfiContentType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiContentType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiContentType] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiContentType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiContentType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiPreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [FfiPreferenceUpdate]

    public static func write(_ value: [FfiPreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiPreferenceUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiPreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiPreferenceUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiPreferenceUpdate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringUInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterUInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: UInt64] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: UInt64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterUInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryDataTypeFfiKeyPackageStatus: FfiConverterRustBuffer {
    public static func write(_ value: [Data: FfiKeyPackageStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterData.write(key, into: &buf)
            FfiConverterTypeFfiKeyPackageStatus.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data: FfiKeyPackageStatus] {
        let len: Int32 = try readInt(&buf)
        var dict = [Data: FfiKeyPackageStatus]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterData.read(from: &buf)
            let value = try FfiConverterTypeFfiKeyPackageStatus.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryDataSequenceTypeFfiHmacKey: FfiConverterRustBuffer {
    public static func write(_ value: [Data: [FfiHmacKey]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterData.write(key, into: &buf)
            FfiConverterSequenceTypeFfiHmacKey.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data: [FfiHmacKey]] {
        let len: Int32 = try readInt(&buf)
        var dict = [Data: [FfiHmacKey]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterData.read(from: &buf)
            let value = try FfiConverterSequenceTypeFfiHmacKey.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeFfiIdentifierBool: FfiConverterRustBuffer {
    public static func write(_ value: [FfiIdentifier: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeFfiIdentifier.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiIdentifier: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [FfiIdentifier: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeFfiIdentifier.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureXmtpv3Initialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
/**
 * * Static apply a signature request
 */
public func applySignatureRequest(api: XmtpApiClient, signatureRequest: FfiSignatureRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_apply_signature_request(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeFfiSignatureRequest_lower(signatureRequest)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
public func connectToBackend(host: String, isSecure: Bool, appVersion: String?)async throws  -> XmtpApiClient  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_connect_to_backend(FfiConverterString.lower(host),FfiConverterBool.lower(isSecure),FfiConverterOptionString.lower(appVersion)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeXmtpApiClient_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
/**
 * It returns a new client of the specified `inbox_id`.
 * Note that the `inbox_id` must be either brand new or already associated with the `account_identifier`.
 * i.e. `inbox_id` cannot be associated with another account address.
 *
 * Prior to calling this function, it's suggested to form `inbox_id`, `account_identifier`, and `nonce` like below.
 *
 * ```text
 * inbox_id = get_inbox_id_for_address(account_identifier)
 * nonce = 0
 *
 * // if inbox_id is not associated, we will create new one.
 * if !inbox_id {
 * if !legacy_key { nonce = random_u64() }
 * inbox_id = generate_inbox_id(account_identifier, nonce)
 * } // Otherwise, we will just use the inbox and ignore the nonce.
 * db_path = $inbox_id-$env
 *
 * xmtp.create_client(account_identifier, nonce, inbox_id, Option<legacy_signed_private_key_proto>)
 * ```
 */
public func createClient(api: XmtpApiClient, syncApi: XmtpApiClient, db: String?, encryptionKey: Data?, inboxId: String, accountIdentifier: FfiIdentifier, nonce: UInt64, legacySignedPrivateKeyProto: Data?, deviceSyncServerUrl: String?, deviceSyncMode: FfiSyncWorkerMode?, allowOffline: Bool?, disableEvents: Bool?)async throws  -> FfiXmtpClient  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_create_client(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeXmtpApiClient_lower(syncApi),FfiConverterOptionString.lower(db),FfiConverterOptionData.lower(encryptionKey),FfiConverterString.lower(inboxId),FfiConverterTypeFfiIdentifier_lower(accountIdentifier),FfiConverterUInt64.lower(nonce),FfiConverterOptionData.lower(legacySignedPrivateKeyProto),FfiConverterOptionString.lower(deviceSyncServerUrl),FfiConverterOptionTypeFfiSyncWorkerMode.lower(deviceSyncMode),FfiConverterOptionBool.lower(allowOffline),FfiConverterOptionBool.lower(disableEvents)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiXmtpClient_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
public func decodeMultiRemoteAttachment(bytes: Data)throws  -> FfiMultiRemoteAttachment  {
    return try  FfiConverterTypeFfiMultiRemoteAttachment_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_decode_multi_remote_attachment(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeReaction(bytes: Data)throws  -> FfiReaction  {
    return try  FfiConverterTypeFfiReaction_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_decode_reaction(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func decodeTransactionReference(bytes: Data)throws  -> FfiTransactionReference  {
    return try  FfiConverterTypeFfiTransactionReference_lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_decode_transaction_reference(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func encodeMultiRemoteAttachment(ffiMultiRemoteAttachment: FfiMultiRemoteAttachment)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_encode_multi_remote_attachment(
        FfiConverterTypeFfiMultiRemoteAttachment_lower(ffiMultiRemoteAttachment),$0
    )
})
}
public func encodeReaction(reaction: FfiReaction)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_encode_reaction(
        FfiConverterTypeFfiReaction_lower(reaction),$0
    )
})
}
public func encodeTransactionReference(reference: FfiTransactionReference)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_encode_transaction_reference(
        FfiConverterTypeFfiTransactionReference_lower(reference),$0
    )
})
}
/**
 * turns on logging to a file on-disk in the directory specified.
 * files will be prefixed with 'libxmtp.log' and suffixed with the timestamp,
 * i.e "libxmtp.log.2025-04-02"
 * A maximum of 'max_files' log files are kept.
 */
public func enterDebugWriter(directory: String, logLevel: FfiLogLevel, rotation: FfiLogRotation, maxFiles: UInt32)throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_enter_debug_writer(
        FfiConverterString.lower(directory),
        FfiConverterTypeFfiLogLevel_lower(logLevel),
        FfiConverterTypeFfiLogRotation_lower(rotation),
        FfiConverterUInt32.lower(maxFiles),$0
    )
}
}
/**
 * turns on logging to a file on-disk with a specified log level.
 * files will be prefixed with 'libxmtp.log' and suffixed with the timestamp,
 * i.e "libxmtp.log.2025-04-02"
 * A maximum of 'max_files' log files are kept.
 */
public func enterDebugWriterWithLevel(directory: String, rotation: FfiLogRotation, maxFiles: UInt32, logLevel: FfiLogLevel)throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_enter_debug_writer_with_level(
        FfiConverterString.lower(directory),
        FfiConverterTypeFfiLogRotation_lower(rotation),
        FfiConverterUInt32.lower(maxFiles),
        FfiConverterTypeFfiLogLevel_lower(logLevel),$0
    )
}
}
/**
 * Flush loglines from libxmtp log writer to the file, ensuring logs are written.
 * This should be called before the program exits, to ensure all the logs in memory have been
 * written. this ends the writer thread.
 */
public func exitDebugWriter()throws   {try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_exit_debug_writer($0
    )
}
}
public func generateInboxId(accountIdentifier: FfiIdentifier, nonce: UInt64)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGenericError_lift) {
    uniffi_xmtpv3_fn_func_generate_inbox_id(
        FfiConverterTypeFfiIdentifier_lower(accountIdentifier),
        FfiConverterUInt64.lower(nonce),$0
    )
})
}
public func getInboxIdForIdentifier(api: XmtpApiClient, accountIdentifier: FfiIdentifier)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_get_inbox_id_for_identifier(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeFfiIdentifier_lower(accountIdentifier)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
public func getVersionInfo() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_xmtpv3_fn_func_get_version_info($0
    )
})
}
/**
 * * Static Get the inbox state for each `inbox_id`.
 */
public func inboxStateFromInboxIds(api: XmtpApiClient, inboxIds: [String])async throws  -> [FfiInboxState]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_inbox_state_from_inbox_ids(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterSequenceString.lower(inboxIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiInboxState.lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}
public func isConnected(api: XmtpApiClient)async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_is_connected(FfiConverterTypeXmtpApiClient_lower(api)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_i8,
            completeFunc: ffi_xmtpv3_rust_future_complete_i8,
            freeFunc: ffi_xmtpv3_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
/**
 * * Static revoke a list of installations
 */
public func revokeInstallations(api: XmtpApiClient, recoveryIdentifier: FfiIdentifier, inboxId: String, installationIds: [Data])async throws  -> FfiSignatureRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_revoke_installations(FfiConverterTypeXmtpApiClient_lower(api),FfiConverterTypeFfiIdentifier_lower(recoveryIdentifier),FfiConverterString.lower(inboxId),FfiConverterSequenceData.lower(installationIds)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiSignatureRequest_lift,
            errorHandler: FfiConverterTypeGenericError_lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_xmtpv3_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_xmtpv3_checksum_func_apply_signature_request() != 65134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_connect_to_backend() != 56931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_create_client() != 18591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment() != 59746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_reaction() != 28885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_decode_transaction_reference() != 25896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment() != 28938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_reaction() != 6548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_encode_transaction_reference() != 22144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_enter_debug_writer() != 7266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level() != 7232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_exit_debug_writer() != 31716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_generate_inbox_id() != 35602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier() != 54811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_get_version_info() != 29277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids() != 55434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_is_connected() != 17295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_func_revoke_installations() != 23629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update() != 12532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error() != 5882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close() != 18566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_admin() != 52417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_members() != 52510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_inbox_id() != 30553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin() != 62984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id() != 12748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_admin_list() != 26668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_consent_state() != 25033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info() != 13258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings() != 53380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_conversation_type() != 43322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns() != 17973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id() != 2178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms() != 15813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_messages() != 19931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions() != 46761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys() != 35284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_description() != 53570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square() != 3200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_metadata() != 7860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_name() != 9344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_group_permissions() != 61947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_id() != 5542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_active() != 49581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_admin() != 12325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled() != 13756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin() != 25811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_list_members() != 21260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version() != 61438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message() != 4359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_publish_messages() != 15643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_admin() != 7973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings() != 37503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_members() != 27638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_inbox_id() != 53192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin() != 46017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_send() != 7954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic() != 5885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_send_text() != 55684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_stream() != 26870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list() != 50610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_sync() != 17206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state() != 27721) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings() != 18023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_group_description() != 14549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square() != 36900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_group_name() != 62600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy() != 3743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation() != 25316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error() != 461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close() != 26905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation() != 20525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked() != 16358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message() != 42510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type() != 22241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id() != 61067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_create_group() != 5386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic() != 41612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_create_group_with_inbox_ids() != 56407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm() != 25610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_inbox_id() != 42164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys() != 44064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_list() != 23197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_list_dms() != 39437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_list_groups() != 7791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message() != 57376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream() != 31576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages() != 7006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages() != 16815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages() != 34596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_consent() != 27123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_dms() != 52710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_groups() != 11064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_messages() != 45879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences() != 37452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_sync() != 9054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations() != 30657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set() != 24928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type() != 56975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier() != 4926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffiinboxowner_sign() != 10423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message() != 5286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error() != 32204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close() != 9150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update() != 19900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error() != 41454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close() != 48198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature() != 8706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature() != 11222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature() != 52793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready() != 65051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures() != 34688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text() != 60472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_end() != 11040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait() != 23074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed() != 62423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready() != 38545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffisyncworker_wait() != 30763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity() != 61490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id() != 29264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics() != 18475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics() != 47055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics() != 31059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request() != 32172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata() != 27089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message() != 32993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier() != 39513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics() != 38737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation() != 60290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations() != 47463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive() != 6966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect() != 6707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation() != 23917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id() != 17517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state() != 58208) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids() != 60893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state() != 3165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive() != 7049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id() != 25128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state() != 7826) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id() != 37173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_message() != 26932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity() != 42003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection() != 11067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations() != 36450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity() != 63231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations() != 2611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request() != 42032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states() != 64566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key() != 42647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request() != 18270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences() != 59168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_upload_debug_archive() != 21347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key() != 3285) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key() != 10898) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFfiConsentCallback()
    uniffiCallbackInitFfiConversationCallback()
    uniffiCallbackInitFfiInboxOwner()
    uniffiCallbackInitFfiMessageCallback()
    uniffiCallbackInitFfiPreferenceCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureXmtpv3Initialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all